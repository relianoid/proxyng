#!/usr/bin/perl
### BEGIN INIT INFO
# Provides:          zenloadbalancer
# Required-Start:
# Required-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: zenloadbalancer
# Description:
#
### END INIT INFO

###############################################################################
#
#     This file is part of the Zen Load Balancer Enterprise Edition software
#     package.
#
#     Copyright (C) 2014 SOFINTEL IT ENGINEERING SL, Sevilla (Spain)
#
#     This file cannot be distributed, released in public domain and/or for
#     commercial purposes.
#
###############################################################################

use Sys::Hostname;
use Date::Parse;
use Time::localtime;
use Tie::File;
use Data::Dumper;

my $limitfile = "/etc/security/limits.conf";
my $globalcfg = "/usr/local/zenloadbalancer/config/global.conf";
require "/usr/local/zenloadbalancer/config/global.conf";
require "/usr/local/zenloadbalancer/www/functions.cgi";
require "/usr/local/zenloadbalancer/www/cluster_functions.cgi";

my $eject                 = $ARGV[0];
my @configured_interfaces = @{ &getConfigInterfaceList() };

if ( !$eject && $eject !~ /stop|start|status|startlocal|stoplocal/ )
{
	print
	  "Usage: /etc/init.d/zenloadbalancer stop|start|status|startlocal|stoplocal\n";
	exit;
}

# build local key
sub keycert    #()
{
	# requires:
	#~ use Sys::Hostname;

	my $dmidecode_bin = "/usr/sbin/dmidecode";    # input
	my $hostname      = hostname();               # input

	my @dmidec  = `$dmidecode_bin`;
	my @dmidec2 = grep ( /UUID\:/, @dmidec );
	my $dmi     = $dmidec2[0];

	$dmi =~ s/\"//g;     # remove doble quotes
	$dmi =~ s/^\s+//;    # remove whitespaces at the begining
	$dmi =~ s/\s+$//;    # remove whitespaces at the end
	$dmi =~ s/\ //g;     # remove spaces

	my @dmidec3 = split ( ":", $dmi );
	$dmi = $dmidec3[1];

	$hostname =~ s/\"//g;     # remove doble quotes
	$hostname =~ s/^\s+//;    # remove whitespaces at the begining
	$hostname =~ s/\s+$//;    # remove whitespaces at the end

	my $encrypted_string  = crypt ( "${dmi}${hostname}", "93" );
	my $encrypted_string2 = crypt ( "${hostname}${dmi}", "a3" );
	my $encrypted_string3 = crypt ( "${dmi}${hostname}", "ZH" );
	my $encrypted_string4 = crypt ( "${hostname}${dmi}", "h7" );
	$encrypted_string =~ s/^93//;
	$encrypted_string2 =~ s/^a3//;
	$encrypted_string3 =~ s/^ZH//;
	$encrypted_string4 =~ s/^h7//;

	my $str =
	  "${encrypted_string}-${encrypted_string2}-${encrypted_string3}-${encrypted_string4}";

	$str =~ s/\"//g;     # remove doble quotes
	$str =~ s/^\s+//;    # remove whitespaces at the begining
	$str =~ s/\s+$//;    # remove whitespaces at the end

	return $str;
}

# evaluate certificate
sub certcontrol          #()
{
	# requires:
	#~ use Sys::Hostname;
	#~ use Date::Parse;
	#~ use Time::localtime;

	# input
	my $hostname    = hostname();
	my $zlbcertfile = "$basedir/zlbcertfile.pem";
	my $openssl_bin = "/usr/bin/openssl";
	my $keyid       = "4B:1B:18:EE:21:4A:B6:F9:76:DE:C3:D8:86:6D:DE:98:DE:44:93:B9";

	# output
	my $swcert = 0;

	if ( -e $zlbcertfile )
	{
		my @zen_cert = `$openssl_bin x509 -in $zlbcertfile -noout -text 2>/dev/null`;

		if (    ( !grep /$key/, @zen_cert )
			 || ( !grep /keyid:$keyid/,   @zen_cert )
			 || ( !grep /CN=$hostname\//, @zen_cert ) )
		{
			$swcert = 2;
		}

		my $now = ctime();

		# Certificate validity date
		my @notbefore = grep /Not Before/i, @zen_cert;
		my $nb = join '', @notbefore;
		$nb =~ s/not before.*:\ //i;
		my $ini = str2time( $nb );

		# Certificate expiring date
		my @notafter = grep /Not After/i, @zen_cert;
		my $na = join "", @notafter;
		$na =~ s/not after.*:\ //i;
		my $end = str2time( $na );

		# Validity remaining
		my $totaldays = ( $end - $ini ) / 86400;
		$totaldays =~ s/\-//g;
		my $dayright = ( $end - time () ) / 86400;

		#control errors
		if ( $totaldays < 364 && $dayright < 0 && $swcert == 0 )
		{
			# Policy: expired testing certificates would not stop zen service,
			# but rebooting the service would not start the service,
			# interfaces should always be available.
			$swcert = 3;
		}

		if ( $totaldays > 364 && $dayright < 0 && $swcert == 0 )
		{
			# The contract support plan is expired you have to request a
			# new contract support. Only message alert!
			$swcert = -1;
		}
	}
	else
	{
		#There isn't certificate in the machine
		$swcert = 1;
	}

	# error codes
	#swcert = 0 ==> OK
	#swcert = 1 ==> There isn't certificate
	#swcert = 2 ==> Cert isn't signed OK
	#swcert = 3 ==> Cert test and it's expired
	#swcert = -1 ==> Cert support and it's expired

	#output
	return $swcert;
}

sub configureDefaultGW    #()
{
	print "\n";
	if ( $ARGV[0] =~ /^start.*/ )
	{
		if ( $defaultgw ne '' && $defaultgwif ne '' )
		{
			my $if_ref = &getInterfaceConfig( $defaultgwif, 4 );
			if ( $if_ref )
			{
				print "Default Gateway:$defaultgw Device:$defaultgwif\n";
				&applyRoutes( "global", $if_ref, $defaultgw );
			}
		}

		if ( $defaultgw6 ne '' && $defaultgwif6 ne '' )
		{
			my $if_ref = &getInterfaceConfig( $defaultgwif, 6 );
			if ( $if_ref )
			{
				print "Default Gateway:$defaultgw6 Device:$defaultgwif6\n";
				&applyRoutes( "global", $if_ref, $defaultgw6 );
			}
		}
	}
}

sub runhttpsgui    #()
{
	if ( $pid = fork )
	{
		#$SIG{'CHLD'}='IGNORE';
	}
	elsif ( defined $pid )
	{
		system ( "/etc/init.d/cherokee start > /dev/null &" );
		exit ( 0 );
	}
}

if ( $eject eq "restart" )
{
	system ( '/etc/init.d/zenloadbalancer stop' );
	system ( '/etc/init.d/zenloadbalancer start' );
}

if ( $eject eq "start" )
{
	&zenlog( "Beginning start proccess" );
	system ( '/usr/local/zenloadbalancer/app/checkglobalconf/checkglobalconf.cgi' );
	require "/usr/local/zenloadbalancer/config/global.conf";

	# Load required modules
	system ( '/sbin/modprobe nf_conntrack >/dev/null 2>&1' );
	system ( '/sbin/modprobe ip_conntrack >/dev/null 2>&1' );
	system ( '/sbin/rmmod xt_recent >/dev/null 2>&1' );
	system (
		"/sbin/modprobe xt_recent ip_list_tot=$recent_ip_list_tot ip_list_hash_size=$recent_ip_list_hash_size >/dev/null 2>&1"
	);

	system ( 'echo "22500" > /sys/module/nf_conntrack/parameters/hashsize' );

	# Set system tuning with sysctl
	$sysctl = "/etc/sysctl.conf";

	tie my @sysctl, 'Tie::File', "$sysctl";
	@sysctl = grep !/^net\.ipv4\.tcp_tw_recycle/, @sysctl;

	my %sysctl = (
				   "fs.file-max"                        => "100000",
				   "vm.max_map_count"                   => "1048576",
				   "vm.swappiness"                      => "10",
				   "net.ipv4.conf.all.log_martians"     => "0",
				   "net.ipv4.ip_local_port_range"       => "1024 65535",
				   "net.ipv4.tcp_max_tw_buckets"        => "2000000",
				   "net.ipv4.tcp_max_syn_backlog"       => "30000",
				   "net.ipv4.tcp_window_scaling"        => "1",
				   "net.ipv4.tcp_timestamps"            => "0",
				   "net.ipv4.tcp_rmem"                  => "4096 87380 16777216",
				   "net.ipv4.tcp_wmem"                  => "4096 65536 16777216",
				   "net.ipv4.udp_rmem_min"              => "8192",
				   "net.ipv4.udp_wmem_min"              => "8192",
				   "net.ipv4.tcp_low_latency"           => "1",
				   "net.ipv4.tcp_tw_reuse"              => "1",
				   "net.ipv4.tcp_tw_recycle"            => "0",
				   "net.ipv4.tcp_keepalive_time"        => "512",
				   "net.ipv4.tcp_fin_timeout"           => "5",
				   "net.ipv4.inet_peer_maxttl"          => "5",
				   "net.ipv4.tcp_keepalive_probes"      => "5",
				   "net.ipv4.tcp_slow_start_after_idle" => "0",
				   "net.ipv4.netfilter.ip_conntrack_udp_timeout_stream"      => "10",
				   "net.ipv4.netfilter.ip_conntrack_tcp_timeout_time_wait"   => "2",
				   "net.ipv4.netfilter.ip_conntrack_tcp_timeout_established" => "86400",
				   "net.netfilter.nf_conntrack_tcp_timeout_time_wait"        => "2",
				   "net.netfilter.nf_conntrack_max"       => "180000",
				   "net.netfilter.nf_conntrack_tcp_loose" => "0",
				   "net.core.rmem_max"                    => "16777216",
				   "net.core.wmem_max"                    => "16777216",
				   "net.core.rmem_default"                => "16777216",
				   "net.core.wmem_default"                => "16777216",
				   "net.core.optmem_max"                  => "40960",
				   "net.ipv4.tcp_keepalive_intvl"         => "15",
				   "net.core.netdev_max_backlog"          => "50000",
				   "net.core.somaxconn"                   => "3000",
	);

	foreach my $key ( sort keys %sysctl )
	{
		# escape dots for regular expression
		my $quoted_key = quotemeta ( $key );

		if ( !grep ( /^$quoted_key/, @sysctl ) )
		{
			push ( @sysctl, "$key = $sysctl{$key}" );
		}
	}

	untie @sysctl;

	my $sysctl_errno = system ( 'sysctl -p > /dev/null' );
	my $sysclt_msg;

	if ( $sysctl_errno )
	{
		$sysclt_msg = "An error happenend applying sysctl policies.";
	}
	else
	{
		$sysclt_msg = "Sysctl applied policies successfully.";
	}

	if ( !grep ( /^kernel\.threads-max/, @sysctl ) )
	{
		push ( @sysctl, "kernel.threads-max = 200000" );
	}
	untie @sysctl;

	&zenlog( $sysclt_msg );

	# Cluster
	if ( -e $filecluster )
	{
		# get cluster configuration
		my (
			 $lhost,  $lip,      $rhost, $rip,       $vipcl, $ifname,
			 $typecl, $clstatus, $cable, $idcluster, $deadratio
		) = &getClusterConfig();
		
		print "Cluster file exist\n";

		if ( $clstatus =~ /UP/ )
		{
			print "UP status configured\n";
			print "Cluster ID: $idcluster\n";
			print "Cluster Deadratio: $deadratio\n";
			print "Host:\t$lhost\n";
			print "CL_LIP:\t$lip\n";
			print "CL_RIP:\t$rip\n";
			print "CL_IF:\t$ifname\n";
			print "CL_IP:\t$vipcl\n";

			#if real interface not configured, configure it
			my ( $phys_iface ) = split ':', $ifname;

			# FIXME: Cluster with IPv6 support
			my $if_ref = &getInterfaceConfig( $phys_iface, 4 );

			&createIf( $if_ref ) if $$if_ref{ vlan } ne '';    # for vlans
			&upIf( $if_ref );

			&addIp( $if_ref );

			&writeRoutes( $$if_ref{ name } );
			&applyRoutes( "local", $if_ref );

			if    ( $typecl =~ /^equal$/ )       { print "CL_TYPE: equal\n"; }
			elsif ( $typecl =~ /$lhost-$rhost/ ) { print "CL_TYPE: M-B, Master node\n"; }
			else                                 { print "CL_TYPE: M-B Backup node\n"; }

			# Runs ucarp to set on/off the node
			# setClusterNodeOffMaintenance > ucarp > zenlatency-(start|stop).pl
			&setClusterNodeOffMaintenance( $cable, $ifname, $deadratio, $lip,
										   $idcluster, $vipcl,  $typecl, $lhost, $rhost );

			#check the gui interface
			print "Running GUI interface\n";
			my $mgmt_ip = GUIip();
			my $mgmt_iface;

			if ( $lip ne $mgmt_ip && &ipisok( $mgmt_ip ) == 'true' )
			{
				# Find management ip configuration
				for my $iface ( @configured_interfaces )
				{
					if ( $mgmt_ip eq $$iface{ addr } )
					{
						$mgmt_iface = $iface;
					}
				}

				if ( $$mgmt_iface{ status } eq "up" )
				{
					print
					  "HTTPS GUI Interface:$$mgmt_iface{name} Ip:$$mgmt_iface{addr} Netmask:$$mgmt_iface{mask}";

					if ( $$mgmt_iface{ gateway } ne '' )
					{
						print " Gateway:$$mgmt_iface{gateway}";
					}

					my $return_code = &addIp( $mgmt_iface );

					&applyRoutes( "local", $mgmt_iface );
					&upIf( $mgmt_iface );

					if ( $return_code == 0 )
					{
						print " \033[1;32m OK \033[0m \n";
					}
					else
					{
						print " \033[1;31m ERROR \033[0m \n";
					}
				}
			}

			sleep ( 5 );

			if ( grep ( /$vipcl/, `$ifconfig_bin` ) )
			{
				#check if virtual interface cluster is up:
				print "CL_IP: $vipcl\n";

				print
				  "Cluster is running on this node, running IPS and FARMS for Zen Load Balancer...\n";
				$eject = 'startlocal';
			}
		}
		else
		{
			$eject = 'startlocal';
		}
	}
	else
	{
		$eject = 'startlocal';
	}

	&zenlog( "start proccess finished" );
}

if ( $eject eq "stop" )
{
	&zenlog( "Beginning stop proccess" );

	if ( -e $filecluster )
	{
		open $fo, "<", "$filecluster";
		@file = <$fo>;
		close $fo;

		if ( grep ( /UP/, @file ) )
		{
			system ( 'pkill -9 ucarp' );
			system ( 'pkill -9f zeninotify.pl' );
			print "Stopping Zen Cluster on this node...\n";
		}

		sleep ( 5 );
	}

	$eject = 'stoplocal';
	&zenlog( "stop proccess finished" );
}

# no cluster configured
if ( $eject eq 'startlocal' )
{
	&zenlog( "Beginning startlocal process..." );
	$rsyslog = '/etc/rsyslog.conf';

	open my $fr, '<', "$rsyslog";
	my @filelog = <$fr>;
	close $fr;

	if ( !grep ( /ucarp/, @filelog ) )
	{
		system (
				 "echo \"local6.* /usr/local/zenloadbalancer/logs/ucarp.log\">> $rsyslog" );
		system ( '/etc/init.d/rsyslog restart' );
	}

	my $bond_conf = &getBondConfig();
	for my $bond_k ( keys %{ $bond_conf } )
	{
		next if $bond_k eq '_';

		my $bond = $bond_conf->{ $bond_k };

		print "  * Up bonding master $$bond{name} ";

		my $error_code = &applyBondChange( $bond );

		if ( $error_code == 0 )
		{
			print " \033[1;32m OK \033[0m \n";
		}
		else
		{
			print " \033[1;31m ERROR \033[0m \n";
		}
	}

	#testing interface configured on the installation and gw
	if ( -e '/etc/network/interfaces' )
	{
		open $fr, '/etc/network/interfaces';
		my @file = <$fr>;
		close $fr;

		if ( !grep ( /zenmodified/, @file ) )
		{
			my ( $ifname, $ip, $netmask, $gateway );

			foreach my $line ( @file )
			{
				chomp ( $line );

				if ( $line =~ /iface.*inet static/i )
				{
					my @iface = split ( " ", $line );
					$ifname = $iface[1];
					chomp ( $ifname );
				}
				if ( $line =~ /address/i )
				{
					my @ip = split ( " ", $line );
					$ip = $ip[1];
					chomp ( $ip );
				}
				if ( $line =~ /netmask/i )
				{
					my @netmask = split ( " ", $line );
					$netmask = $netmask[1];
					chomp ( $netmask );
				}
				if ( $line =~ /gateway/i )
				{
					my @gateway = split ( " ", $line );
					$gateway = $gateway[1];
					chomp ( $gateway );
				}
			}

			#deleting interfaces file
			open FW, ">/etc/network/interfaces";
			print FW "#zenmodified\n";
			print FW "auto lo\n";
			print FW "iface lo inet loopback\n";
			close FW;

			#creating configuration interface file:
			open FW, ">$configdir\/if\_$ifname\_conf";
			print FW "$ifname;;$ip;$netmask;;\n";
			close FW;

			#configure gateway
			tie my @contents, 'Tie::File', "$globalcfg";

			for my $line ( @contents )
			{
				if ( grep /^\$defaultgw/, $line )    # FIXME: IPv6 gateway
				{
					$line =~ s/^\$defaultgw=.*/\$defaultgw="$gateway";/g;
					$line =~ s/^\$defaultgwif=.*/\$defaultgwif="$ifname";/g;
				}
			}

			untie @contents;

			#routes
			open FW, ">>/etc/iproute2/rt_tables";
			print FW "200\ttable_$ifname\n";
			close FW;

			@configured_interfaces = @{ &getConfigInterfaceList() };
		}
	}

	### Starting Network Interfaces
	print "Starting Zen Load Balancer...\n";
	print "* Starting Interfaces:\n";

	my $mgmt_ip = &GUIip();

	#first real interfaces
	foreach my $iface ( @configured_interfaces )
	{
		#interfaces as eth0 for example
		if ( $$iface{ name } eq $$iface{ dev } )
		{
			if ( $$iface{ status } eq "up" )
			{
				print "  * Starting interface $$iface{name}\n";
				print "    Ip:$$iface{addr} Netmask:$$iface{mask}";

				if ( $$iface{ gateway } ne '' )
				{
					print " Gateway:$$iface{gateway}";
				}

				my $socket   = &getIOSocket();
				my $if_flags = $socket->if_flags( $$iface{ name } );

				if ( !( $if_flags & IFF_UP ) )
				{
					my $return_code = &addIp( $iface );

					if ( $return_code )
					{
						my @ip_output = `$ip_bin address show dev $$iface{name}`;
						$return_code = 0 if ( grep /$$iface{addr}/, @ip_output );
					}

					&writeRoutes( $$iface{ name } );
					&applyRoutes( "local", $iface );
					&upIf( $iface );

					if ( $return_code == 0 )
					{
						print " \033[1;32m OK \033[0m \n";
					}
					else
					{
						print " \033[1;31m ERROR \033[0m \n";
					}

					if ( $$iface{ ip_v } == 4 )
					{
						&sendGArp( $$iface{ name }, $$iface{ addr } );
					}
				}
				elsif ( $$iface{ addr } eq $mgmt_ip && !( $if_flags & IFF_UP ) )
				{
					print " \033[1;32m OK \033[0m \n";
				}
			}
		}
	}

	#interfaces as eth0.20 for example
	foreach my $iface ( @configured_interfaces )
	{
		if ( $$iface{ vlan } ne '' && $$iface{ vini } eq '' )
		{
			if ( $$iface{ status } eq "up" )
			{
				print "  * Starting interface $$iface{name}\n";
				print "    Ip:$$iface{addr} Netmask:$$iface{mask}";

				if ( $$iface{ gateway } ne '' )
				{
					print " Gateway:$$iface{gateway}";
				}

				&createIf( $iface );
				&upIf( $iface );

				my $return_code = &addIp( $iface );
				if ( $return_code )
				{
					my @ip_output = `$ip_bin address show dev $$iface{name}`;
					$return_code = 0 if ( grep /$$iface{addr}/, @ip_output );
				}

				if ( $return_code == 0 )
				{
					print " \033[1;32m OK \033[0m \n";
				}
				else
				{
					print " \033[1;31m ERROR \033[0m \n";
				}

				&writeRoutes( $$iface{ name } );
				&applyRoutes( "local", $iface );

				if ( $$iface{ ip_v } == 4 )
				{
					&sendGArp( $$iface{ name }, $$iface{ addr } );
				}
			}
		}
	}

	#interfaces as eth0:20 || eth0.20:2 for example
	foreach my $iface ( @configured_interfaces )
	{
		if ( $$iface{ vini } ne '' )
		{
			if ( $$iface{ status } eq "up" )
			{
				print "  * Starting interface $$iface{name}\n";
				print "    Ip:$$iface{addr} Netmask:$$iface{mask}";

				my $return_code = &addIp( $iface );

				#~ print("addIp: done");
				if ( $return_code )
				{
					my $toif = &getParentInterfaceName( $$iface{ name } );
					&zenlog( "failed addIp" );
					my @ip_output = `$ip_bin -$$iface{ip_v} address list dev $toif`;
					$return_code = 0 if ( grep /$$iface{addr}/, @ip_output );
				}

				#~ print("applyRoutes: start");
				&applyRoutes( "local", $iface );

				#~ print("applyRoutes: done");

				if ( $return_code == 0 )
				{
					print " \033[1;32m OK \033[0m \n";
				}
				else
				{
					print " \033[1;31m ERROR \033[0m \n";
				}

				if ( $$iface{ ip_v } == 4 )
				{
					&sendGArp( $$iface{ name }, $$iface{ addr } );
				}
			}
		}
	}

	$key    = &keycert();
	my $swcert = &certcontrol( $typecall );

	# error codes:

	# valid values for farms:
	#swcert = -1 ==> Cert valid (>365) and it's expired
	#swcert = 0 ==> OK

	# not valid values for farms:
	#swcert = 1 ==> There isn't certificate
	#swcert = 2 ==> Cert isn't signed OK
	#swcert = 3 ==> Cert test and it's expired

	if ( $swcert < 1 )
	{
		### Starting Farms
		print "* Starting Farms:\n";
		@farmsf = &getFarmList();

		foreach my $ffile ( @farmsf )
		{
			$farmname = &getFarmName( $ffile );
			$bstatus  = &getFarmBootStatus( $farmname );

			if ( $bstatus eq "up" )
			{
				print "  * Starting Farm $farmname:";
				$status = &_runFarmStart( $farmname, "false" );

				if ( $status == 0 )
				{
					print " \033[1;32m OK \033[0m \n";
				}
				else
				{
					print " \033[1;31m ERROR \033[0m \n";
				}

				#farmguardian configured and up?
				$fgstatus = &getFarmGuardianStatus( $farmname );

				if ( ( $status == 0 ) && ( $fgstatus == 1 ) )
				{
					print "  * Starting Farm Guardian for $farmname:";
					$stat = &runFarmGuardianStart( $farmname, "" );

					if ( $stat == 0 )
					{
						print " \033[1;32m OK \033[0m \n";
					}
					else
					{
						print " \033[1;31m ERROR \033[0m \n";
					}
				}
			}
			else
			{
				print "  Farm $farmname configured DOWN\n";
			}
		}

		#At this point every zen interfaces and farms are running
		#now a personalized script can be executed
		my @ownscript = `$configdir/zlb-start`;
		print "@ownscript";
	}
	else
	{
		print ( "No valid ZLB certificate was found, no farm started\n" );
	}

	&zenlog( "startlocal process finished..." );
}

if ( $eject eq "stoplocal" )
{
	&zenlog( "Beginning stoplocal process..." );
	print "Stopping Zen Load Balancer...\n";

	### Stopping Farms
	print "* Stopping Farms:\n";

	my @farmsf = &getFarmList();

	foreach my $ffile ( @farmsf )
	{
		my $farmname = &getFarmName( $ffile );
		my $status   = &getFarmStatus( $farmname );

		if ( $status eq "up" )
		{
			#farmguardian configured and up?
			my $fgstatus = &getFarmGuardianPid( $farmname );

			if ( $fgstatus != -1 )
			{
				print "  * Stopping Farm Guardian for $farmname:";
				my $stat = &runFarmGuardianStop( $farmname, "" );

				if ( $stat == 0 )
				{
					print " \033[1;32m OK \033[0m \n";
				}
				else
				{
					print " \033[1;31m ERROR \033[0m \n";
				}
			}
			print "  * Stopping Farm $farmname:";
			my $status = &_runFarmStop( $farmname, "false" );

			if ( $status == 0 )
			{
				print " \033[1;32m OK \033[0m \n";
			}
			else
			{
				print " \033[1;31m ERROR \033[0m \n";
			}
		}
	}

	### Stopping Network Interfaces
	print "* Stopping Interfaces:\n";

	# First Virtual Network Interfaces
	foreach my $iface ( @configured_interfaces )
	{
		if ( $$iface{ vini } ne '' )
		{
			print "  * Down interface $$iface{name}\n";
			print "    Ip:$$iface{addr} Netmask:$$iface{mask}";

			my $return_code = &downIf( $iface );

			if ( $return_code == 0 )
			{
				print " \033[1;32m OK \033[0m \n";
			}
			else
			{
				print " \033[1;31m ERROR \033[0m \n";
			}
		}
	}

	# Second Vlans
	foreach my $iface ( @configured_interfaces )
	{
		if ( $$iface{ vlan } ne '' && $$iface{ vini } eq '' )
		{
			if ( $$iface{ status } eq "up" )
			{
				print "  * Down interface $$iface{name}\n";
				print "    Ip:$$iface{addr} Netmask:$$iface{mask}";

				my $return_code = &downIf( $iface );

				if ( $return_code == 0 )
				{
					print " \033[1;32m OK \033[0m \n";
				}
				else
				{
					print " \033[1;31m ERROR \033[0m \n";
				}
			}
		}
	}

	my $mgmt_ip    = &GUIip();
	my $mgmt_iface = &getInterfaceOfIp( $mgmt_ip );

	# Finally Eth
	foreach my $iface ( @configured_interfaces )
	{
		if ( $$iface{ vlan } eq '' && $$iface{ vini } eq '' )
		{
			if ( $$iface{ status } eq "up" )
			{
				next if $$iface{ name } eq $mgmt_iface;

				print "  * Down interface $$iface{name}\n";
				print "    Ip:$$iface{addr} Netmask:$$iface{mask}";

				if ( -e $filecluster )
				{
					# if interface is not mentioned in cluster file _and_ this ip is not the gui ip
					if ( !grep ( /$$iface{name}/, @filecl ) && $mgmt_ip ne $$iface{ addr } )
					{
						my $return_code = &downIf( $iface );

						if ( $return_code == 0 )
						{
							print " \033[1;32m OK \033[0m \n";
						}
						else
						{
							print " \033[1;31m ERROR \033[0m \n";
						}
					}
					else
					{
						print
						  " \033[1;31m This interface is part of a cluster, it cannot be stopped while being part of the cluster.\033[0m \n";
					}
				}
				else
				{
					if ( $mgmt_ip ne $$iface{ addr } )
					{
						my $return_code = &downIf( $iface );

						if ( $return_code == 0 )
						{
							print " \033[1;32m OK \033[0m \n";
						}
						else
						{
							print " \033[1;31m ERROR \033[0m \n";
						}
					}
					else
					{
						print "  no DOWN, it is the Zen GUI\n";
					}
				}
			}
		}
	}

	my $bond_conf = &getBondConfig();
	for my $bond_k ( keys %{ $bond_conf } )
	{
		next if $bond_k eq '_';

		my $bond = $bond_conf->{ $bond_k };

		print "  * Down bonding master $$bond{name} ";

		my $error_code = &setBondMaster( $$bond{name}, 'del' );

		if ( $error_code == 0 )
		{
			print " \033[1;32m OK \033[0m \n";
		}
		else
		{
			print " \033[1;31m ERROR \033[0m \n";
		}
	}

	#At this point all zen interfaces and farms are stopped
	#now a personalized script can be executed
	my @ownscript = `$configdir/zlb-stop`;
	print "@ownscript";

	&zenlog( "stoplocal process finished..." );
}

&runhttpsgui();
&configureDefaultGW();
