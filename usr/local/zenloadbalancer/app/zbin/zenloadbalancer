#!/usr/bin/perl
### BEGIN INIT INFO
# Provides:          zenloadbalancer
# Required-Start:
# Required-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: zenloadbalancer
# Description:
#
### END INIT INFO
###############################################################################
#
#    Zevenet Software License
#    This file is part of the Zevenet Load Balancer software package.
#
#    Copyright (C) 2014-today ZEVENET SL, Sevilla (Spain)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

# use strict;
# use warnings;

use Date::Parse;
use Time::localtime;
use Tie::File;
use Data::Dumper;

my $limitfile = "/etc/security/limits.conf";
my $globalcfg = "/usr/local/zenloadbalancer/config/global.conf";
require "/usr/local/zenloadbalancer/config/global.conf";
require "/usr/local/zenloadbalancer/www/functions.cgi";

my $basedir = &getGlobalConfiguration('basedir');
my $configdir = &getGlobalConfiguration('configdir');
my $defaultgw = &getGlobalConfiguration('defaultgw');
my $defaultgwif = &getGlobalConfiguration('defaultgwif');
my $defaultgw6 = &getGlobalConfiguration('defaultgw6');
my $defaultgwif6 = &getGlobalConfiguration('defaultgwif6');

my $eject                 = $ARGV[0];
my @configured_interfaces = @{ &getConfigInterfaceList() };

# cluster
my $zcl_configured = &getZClusterStatus();

my $master_node;
if ( $zcl_configured && -f &getGlobalConfiguration('znode_status_file') )
{
	$master_node = ( &getZClusterNodeStatus() eq 'master' );
}
my $allow_fg = ( !$zcl_configured || ( $zcl_configured && $master_node ) );

if ( !$eject && $eject !~ /stop|start|status/ )
{
	print "Usage: /etc/init.d/zenloadbalancer stop|start|status\n";
	exit 0;
}

sub printAndLog
{
	my @input = @_;

	print ( @input );
	#~ &zenlog( @input );
}

# build local key
sub keycert    #()
{
	# requires:
	#~ use Sys::Hostname;

	my $dmidecode_bin = "/usr/sbin/dmidecode";    # input
	my $hostname      = &getHostname();               # input

	my @dmidec  = `$dmidecode_bin`;
	my @dmidec2 = grep ( /UUID\:/, @dmidec );
	my $dmi     = $dmidec2[0];

	$dmi =~ s/\"//g;     # remove doble quotes
	$dmi =~ s/^\s+//;    # remove whitespaces at the begining
	$dmi =~ s/\s+$//;    # remove whitespaces at the end
	$dmi =~ s/\ //g;     # remove spaces

	my @dmidec3 = split ( ":", $dmi );
	$dmi = $dmidec3[1];

	$hostname =~ s/\"//g;     # remove doble quotes
	$hostname =~ s/^\s+//;    # remove whitespaces at the begining
	$hostname =~ s/\s+$//;    # remove whitespaces at the end

	my $encrypted_string  = crypt ( "${dmi}${hostname}", "93" );
	my $encrypted_string2 = crypt ( "${hostname}${dmi}", "a3" );
	my $encrypted_string3 = crypt ( "${dmi}${hostname}", "ZH" );
	my $encrypted_string4 = crypt ( "${hostname}${dmi}", "h7" );
	$encrypted_string =~ s/^93//;
	$encrypted_string2 =~ s/^a3//;
	$encrypted_string3 =~ s/^ZH//;
	$encrypted_string4 =~ s/^h7//;

	my $str =
	  "${encrypted_string}-${encrypted_string2}-${encrypted_string3}-${encrypted_string4}";

	$str =~ s/\"//g;     # remove doble quotes
	$str =~ s/^\s+//;    # remove whitespaces at the begining
	$str =~ s/\s+$//;    # remove whitespaces at the end

	return $str;
}

# evaluate certificate
sub certcontrol          #()
{
	# requires:
	#~ use Sys::Hostname;
	#~ use Date::Parse;
	#~ use Time::localtime;

	# input
	my $hostname    = &getHostname();
	my $zlbcertfile = "$basedir/zlbcertfile.pem";
	my $openssl_bin = "/usr/bin/openssl";
	my $keyid       = "4B:1B:18:EE:21:4A:B6:F9:76:DE:C3:D8:86:6D:DE:98:DE:44:93:B9";

	# output
	my $swcert = 0;

	if ( -e $zlbcertfile )
	{
		my @zen_cert = `$openssl_bin x509 -in $zlbcertfile -noout -text 2>/dev/null`;
		my $key = &keycert();

		if (    ( !grep /$key/, @zen_cert )
			 || ( !grep /keyid:$keyid/,   @zen_cert )
			 || ( !grep /CN=$hostname\/|CN = $hostname\,/, @zen_cert ) )
		{
			$swcert = 2;
		}

		my $now = ctime();

		# Certificate validity date
		my @notbefore = grep /Not Before/i, @zen_cert;
		my $nb = join '', @notbefore;
		$nb =~ s/not before.*:\ //i;
		my $ini = str2time( $nb );

		# Certificate expiring date
		my @notafter = grep /Not After/i, @zen_cert;
		my $na = join "", @notafter;
		$na =~ s/not after.*:\ //i;
		my $end = str2time( $na );

		# Validity remaining
		my $totaldays = ( $end - $ini ) / 86400;
		$totaldays =~ s/\-//g;
		my $dayright = ( $end - time () ) / 86400;

		#control errors
		if ( $totaldays < 364 && $dayright < 0 && $swcert == 0 )
		{
			# Policy: expired testing certificates would not stop zen service,
			# but rebooting the service would not start the service,
			# interfaces should always be available.
			$swcert = 3;
		}

		if ( $totaldays > 364 && $dayright < 0 && $swcert == 0 )
		{
			# The contract support plan is expired you have to request a
			# new contract support. Only message alert!
			$swcert = -1;
		}
	}
	else
	{
		#There isn't certificate in the machine
		$swcert = 1;
	}

	# error codes
	#swcert = 0 ==> OK
	#swcert = 1 ==> There isn't certificate
	#swcert = 2 ==> Cert isn't signed OK
	#swcert = 3 ==> Cert test and it's expired
	#swcert = -1 ==> Cert support and it's expired

	#output
	return $swcert;
}


sub local_http_service
{
	my ( $command ) = @_;

	die "local_http_service command not recognized"
		unless $command =~ /^(?:start|stop)$/;

	my $pid;

	if ( $pid = fork )
	{
		#$SIG{'CHLD'}='IGNORE';
	}
	elsif ( defined $pid )
	{
		system ( "/etc/init.d/cherokee $command >/dev/null &" );
		exit ( 0 );
	}
}

if ( $eject eq "restart" )
{
	system ( '/etc/init.d/zenloadbalancer stop' );
	system ( '/etc/init.d/zenloadbalancer start' );
}

if ( $eject eq "start" )
{
	my $version = &getGlobalConfiguration('version');
	&zenlog( "Starting ZEVENET Load Balancer v$version" );
	&zenlog( "Beginning start proccess" );
	require "/usr/local/zenloadbalancer/config/global.conf";
	require "/usr/local/zenloadbalancer/www/notifications.cgi";
	require "/usr/local/zenloadbalancer/www/blacklists.cgi";
	require "/usr/local/zenloadbalancer/www/dos.cgi";

	#### Starts node tuning ####

	# Load required modules
	my $missing_bonding = system ( 'lsmod | grep bonding >/dev/null' );
	if ( $missing_bonding )
	{
		system ( '/sbin/modprobe bonding >/dev/null 2>&1' );
		my $bonding_masters_filename = &getGlobalConfiguration('bonding_masters_filename');
		system ( "echo -bond0 > $bonding_masters_filename" );
	}
	system ( '/sbin/modprobe nf_conntrack >/dev/null 2>&1' );
	system ( '/sbin/modprobe ip_conntrack >/dev/null 2>&1' );
	system ( '/sbin/rmmod xt_recent >/dev/null 2>&1' );
	my $recent_ip_list_tot = &getGlobalConfiguration('recent_ip_list_tot');
	my $recent_ip_list_hash_size = &getGlobalConfiguration('recent_ip_list_hash_size');
	system (
		"/sbin/modprobe xt_recent ip_list_tot=$recent_ip_list_tot ip_list_hash_size=$recent_ip_list_hash_size >/dev/null 2>&1"
	);

	system ( 'echo "22500" > /sys/module/nf_conntrack/parameters/hashsize' );

	# Set system tuning with sysctl
	my $sysctl_conffile = "/etc/sysctl.conf";

	tie my @sysctl_file, 'Tie::File', "$sysctl_conffile";
	@sysctl_file = grep !/^net\.ipv4\.tcp_tw_recycle/, @sysctl_file;

	# In Stretch Debian not appear "net.ipv4.netfilter.ip_conntrack*" variables
	# Debian stretch is used in Zevenet 5000
	my $appliance_version = &getApplianceVersion();
	&zenlog ("Appliance version: $appliance_version");
	$appliance_version =~ /[\w+] (\d)\d+/;
	$appliance_version = $1;
	my %sysctl;
	#  ZVA lower than 5000 
	if ( $appliance_version < 5 )
	{
		%sysctl = (
				   "fs.file-max"                        => "100000",
				   "vm.max_map_count"                   => "1048576",
				   "vm.swappiness"                      => "10",
				   "net.ipv4.conf.all.log_martians"     => "0",
				   "net.ipv4.ip_local_port_range"       => "1024 65535",
				   "net.ipv4.tcp_max_tw_buckets"        => "2000000",
				   "net.ipv4.tcp_max_syn_backlog"       => "30000",
				   "net.ipv4.tcp_window_scaling"        => "1",
				   "net.ipv4.tcp_timestamps"            => "0",
				   "net.ipv4.tcp_rmem"                  => "4096 87380 16777216",
				   "net.ipv4.tcp_wmem"                  => "4096 65536 16777216",
				   "net.ipv4.udp_rmem_min"              => "65536",
				   "net.ipv4.udp_wmem_min"              => "65536",
				   "net.ipv4.tcp_low_latency"           => "1",
				   "net.ipv4.tcp_tw_reuse"              => "1",
				   "net.ipv4.tcp_tw_recycle"            => "0",
				   "net.ipv4.tcp_keepalive_time"        => "512",
				   "net.ipv4.tcp_fin_timeout"           => "5",
				   "net.ipv4.inet_peer_maxttl"          => "5",
				   "net.ipv4.tcp_keepalive_probes"      => "5",
				   "net.ipv4.tcp_slow_start_after_idle" => "0",
				   "net.ipv4.netfilter.ip_conntrack_udp_timeout"             => "2",
				   "net.ipv4.netfilter.ip_conntrack_udp_timeout_stream"      => "2",
				   "net.ipv4.netfilter.ip_conntrack_tcp_timeout_time_wait"   => "2",
				   "net.ipv4.netfilter.ip_conntrack_tcp_timeout_established" => "86400",
				   "net.netfilter.nf_conntrack_tcp_timeout_time_wait"        => "2",
				   "net.netfilter.nf_conntrack_max"       => "180000",
				   "net.netfilter.nf_conntrack_tcp_loose" => "0",
				   "net.core.rmem_max"                    => "16777216",
				   "net.core.wmem_max"                    => "16777216",
				   "net.core.rmem_default"                => "16777216",
				   "net.core.wmem_default"                => "16777216",
				   "net.core.optmem_max"                  => "40960",
				   "net.ipv4.tcp_keepalive_intvl"         => "15",
				   "net.core.netdev_max_backlog"          => "50000",
				   "net.core.somaxconn"                   => "3000",
				   "net.ipv4.ip_nonlocal_bind" 		  => "1",
		);
	}
	#  ZVA higher than 5000 
	else
	{
		%sysctl = (
				   "fs.file-max"                        => "100000",
				   "vm.max_map_count"                   => "1048576",
				   "vm.swappiness"                      => "10",
				   "net.ipv4.conf.all.log_martians"     => "0",
				   "net.ipv4.ip_local_port_range"       => "1024 65535",
				   "net.ipv4.tcp_max_tw_buckets"        => "2000000",
				   "net.ipv4.tcp_max_syn_backlog"       => "30000",
				   "net.ipv4.tcp_window_scaling"        => "1",
				   "net.ipv4.tcp_timestamps"            => "0",
				   "net.ipv4.tcp_rmem"                  => "4096 87380 16777216",
				   "net.ipv4.tcp_wmem"                  => "4096 65536 16777216",
				   "net.ipv4.udp_rmem_min"              => "65536",
				   "net.ipv4.udp_wmem_min"              => "65536",
				   "net.ipv4.tcp_low_latency"           => "1",
				   "net.ipv4.tcp_tw_reuse"              => "1",
				   "net.ipv4.tcp_tw_recycle"            => "0",
				   "net.ipv4.tcp_keepalive_time"        => "512",
				   "net.ipv4.tcp_fin_timeout"           => "5",
				   "net.ipv4.inet_peer_maxttl"          => "5",
				   "net.ipv4.tcp_keepalive_probes"      => "5",
				   "net.ipv4.tcp_slow_start_after_idle" => "0",
				   "net.netfilter.nf_conntrack_udp_timeout"             => "2",
				   "net.netfilter.nf_conntrack_udp_timeout_stream"      => "2",
				   "net.netfilter.nf_conntrack_tcp_timeout_time_wait"   => "2",
				   "net.netfilter.nf_conntrack_tcp_timeout_established" => "86400",
				   "net.netfilter.nf_conntrack_max"       => "180000",
				   "net.netfilter.nf_conntrack_tcp_loose" => "0",
				   "net.core.rmem_max"                    => "16777216",
				   "net.core.wmem_max"                    => "16777216",
				   "net.core.rmem_default"                => "16777216",
				   "net.core.wmem_default"                => "16777216",
				   "net.core.optmem_max"                  => "40960",
				   "net.ipv4.tcp_keepalive_intvl"         => "15",
				   "net.core.netdev_max_backlog"          => "50000",
				   "net.core.somaxconn"                   => "3000",
				   "net.ipv4.ip_nonlocal_bind" 		  => "1",
		);
	}

	foreach my $key ( sort keys %sysctl )
	{
		# escape dots for regular expression
		my $quoted_key = quotemeta ( $key );

		if ( !grep ( /^$key = $sysctl{$key}/, @sysctl_file ) )
		{
			push ( @sysctl_file, "$key = $sysctl{$key}" );
		} else {
			s/^$quoted_key .*/$key = $sysctl{$key}/ for @sysctl_file;
		}
	}

	untie @sysctl_file;

	my $sysctl_errno = system ( 'sysctl -p > /dev/null' );
	my $sysclt_msg;

	if ( $sysctl_errno )
	{
		$sysclt_msg = "An error happenend applying sysctl policies.";
	}
	else
	{
		$sysclt_msg = "Sysctl applied policies successfully.";
	}

	&zenlog( $sysclt_msg );
	#### End of node tuning ####

	# import system interface to zen if configured
	#testing interface configured on the installation and gw
	if ( -e '/etc/network/interfaces' )
	{
		open my $fr, '/etc/network/interfaces';
		my @file = <$fr>;
		close $fr;

		if ( !grep ( /zenmodified/, @file ) )
		{
			my ( $ifname, $ip, $netmask, $gateway );

			foreach my $line ( @file )
			{
				chomp ( $line );

				if ( $line =~ /iface.*inet static/i )
				{
					my @iface = split ( " ", $line );
					$ifname = $iface[1];
					chomp ( $ifname );
				}
				if ( $line =~ /address/i )
				{
					my @ip = split ( " ", $line );
					$ip = $ip[1];
					my $ip_mask = $ip;
					my @ip_nomask = split("/",$ip);
					$ip = @ip_nomask[0];
					chomp ( $ip );
					#bit mask
					use Net::Netmask;
					my $in="$ip/@ip_nomask[1]";
					my $cidr = $in;
					my $block = Net::Netmask->new2( $cidr ) or die $Net::Netmask::error;
					$netmask = $block->mask;
					
				}
				if ( $line =~ /netmask/i )
				{
					my @netmask = split ( " ", $line );
					$netmask = $netmask[1];
					chomp ( $netmask );
				}
				if ( $line =~ /gateway/i )
				{
					my @gateway = split ( " ", $line );
					$gateway = $gateway[1];
					chomp ( $gateway );
				}
			}

			#deleting interfaces file
			open FW, ">/etc/network/interfaces";
			print FW "#zenmodified\n";
			print FW "auto lo\n";
			print FW "iface lo inet loopback\n";
			close FW;

			my %interface = (
							  name    => $ifname,
							  addr    => $ip,
							  mask    => $netmask,
							  gateway => $gateway,
							  status  => "up",
							  name    => "$ifname",
			);

			&setInterfaceConfig( \%interface );

			#configure gateway
			tie my @contents, 'Tie::File', "$globalcfg";

			for my $line ( @contents )
			{
				if ( grep /^\$defaultgw/, $line )    # FIXME: IPv6 gateway
				{
					$line =~ s/^\$defaultgw=.*/\$defaultgw="$gateway";/g;
					$line =~ s/^\$defaultgwif=.*/\$defaultgwif="$ifname";/g;
				}
			}

			untie @contents;

			#routes
			open FW, ">>/etc/iproute2/rt_tables";
			print FW "200\ttable_$ifname\n";
			close FW;

			@configured_interfaces = @{ &getConfigInterfaceList() };
		}
	}

	#configuring bonding
	my $bond_conf = &getBondConfig();
	for my $bond_k ( keys %{ $bond_conf } )
	{
		next if $bond_k eq '_';

		my $bond = $bond_conf->{ $bond_k };

		print "  * Up bonding master $$bond{name} ";

		my $error_code = &applyBondChange( $bond );

		if ( $error_code == 0 )
		{
			print " \033[1;32m OK \033[0m \n";
		}
		else
		{
			print " \033[1;31m ERROR \033[0m \n";
		}
	}

	# start all modules
	&zlbstartNotifications();
	&setBLStart();
	&setDOSBoot();

	### Starting Network Interfaces
	&printAndLog( "Starting ZEVENET Load Balancer...\n" );
	&printAndLog( "* Starting Interfaces:\n" );

	my $mgmt_ip = &getHttpServerIp();
	my $ip_bin = &getGlobalConfiguration('ip_bin');

	#first real interfaces
	foreach my $iface ( @configured_interfaces )
	{
		#interfaces as eth0 for example
		if ( $$iface{ name } eq $$iface{ dev } )
		{
			use IO::Interface ':flags';

			if ( $$iface{ status } eq "up" )
			{
				&printAndLog( "  * Starting interface $$iface{name}\n" );
				&printAndLog( "    Ip:$$iface{addr} Netmask:$$iface{mask}" );

				if ( $$iface{ gateway } ne '' )
				{
					&printAndLog( " Gateway:$$iface{gateway}" );
				}

				&upIf( $iface );
				my $return_code = &addIp( $iface );

				if ( $return_code )
				{
					my @ip_output = `$ip_bin address show dev $$iface{name}`;
					$return_code = 0 if ( grep /$$iface{addr}/, @ip_output );
				}

				# kept in case it is required for first interface
				&writeRoutes( $$iface{ name } );

				&applyRoutes( "local", $iface );

				if ( $return_code == 0 )
				{
					print( " \033[1;32m OK \033[0m \n" );
				}
				else
				{
					print( " \033[1;31m ERROR \033[0m \n" );
				}

				if ( $$iface{ ip_v } == 4 )
				{
					&sendGPing( $$iface{ name } );
				}
			}
		}
	}

	#interfaces as eth0.20 for example
	foreach my $iface ( @configured_interfaces )
	{
		if ( $$iface{ vlan } ne '' && $$iface{ vini } eq '' )
		{
			&createIf( $iface );
			my $return_code = &addIp( $iface );

			if ( $$iface{ status } eq "up" )
			{
				&printAndLog( "  * Starting interface $$iface{name}\n" );
				&printAndLog( "    Ip:$$iface{addr} Netmask:$$iface{mask}" );

				if ( $$iface{ gateway } ne '' )
				{
					&printAndLog( " Gateway:$$iface{gateway}" );
				}

				&upIf( $iface );

				if ( $return_code )
				{
					my @ip_output = `$ip_bin address show dev $$iface{name}`;
					$return_code = 0 if ( grep /$$iface{addr}/, @ip_output );
				}

				if ( $return_code == 0 )
				{
					print( " \033[1;32m OK \033[0m \n" );
				}
				else
				{
					print( " \033[1;31m ERROR \033[0m \n" );
				}

				&applyRoutes( "local", $iface );

				if ( $$iface{ ip_v } == 4 )
				{
					&sendGPing( $$iface{ name } );
				}
			}
		}
	}

	if ( $zcl_configured )
	{
		&zenlog( "Cluster configuration found" );

		my $znode_status_file = &getGlobalConfiguration('znode_status_file');

		my $zcl_conf = &getZClusterConfig();

		# detect master node
		# run command remotely on all nodes
		my $remote_ip = $zcl_conf->{ &getZClusterRemoteHost() }->{ ip };

		my $remote_node_status = &runRemotely( "cat $znode_status_file", $remote_ip );

		# force sync with master
		if ( $remote_node_status eq 'master' )
		{
			# force remote sync
			my $zcluster_manager = &getGlobalConfiguration('zcluster_manager');

			&runRemotely( "$zcluster_manager sync", $remote_ip );
			&enableZCluster( 10 );
			&zenlog("enableZCluster returned");
		}

		# disable ip announcement
		#if not master already
		if ( &getZClusterNodeStatus() ne 'master' )
		{
			foreach my $iface ( @configured_interfaces )
			{
				next if ( $$iface{ vini } eq '' );
				next if ( $$iface{ status } ne "up" );

				&disableInterfaceDiscovery( $iface );
			}
		}
	}
	else
	{
		&zenlog( "Cluster configuration not found" );
	}

	#interfaces as eth0:20 || eth0.20:2 for example
	foreach my $iface ( @configured_interfaces )
	{
		if ( $$iface{ vini } ne '' )
		{
			if ( $$iface{ status } eq "up" )
			{
				&printAndLog( "  * Starting interface $$iface{name}\n" );
				&printAndLog( "    Ip:$$iface{addr} Netmask:$$iface{mask}" );

				my $return_code = &addIp( $iface );

				if ( $return_code )
				{
					my $toif = &getParentInterfaceName( $$iface{ name } );
					&zenlog( "failed addIp" );
					my @ip_output = `$ip_bin -$$iface{ip_v} address list dev $toif`;
					$return_code = 0 if ( grep /$$iface{addr}/, @ip_output );
				}

				&applyRoutes( "local", $iface );

				if ( $return_code == 0 )
				{
					print( " \033[1;32m OK \033[0m \n" );
				}
				else
				{
					print( " \033[1;31m ERROR \033[0m \n" );
				}

				if ( $$iface{ ip_v } == 4 )
				{
					my ( $parent_if ) = split ( ":", $$iface{ name } );
					&sendGPing( $parent_if );
				}
			}
		}
	}

	my $swcert = &certcontrol();

	# error codes:
	#
	# valid values for farms:
	#swcert = -1 ==> Cert valid (>365) and it's expired
	#swcert = 0 ==> OK
	#
	# not valid values for farms:
	#swcert = 1 ==> There isn't certificate
	#swcert = 2 ==> Cert isn't signed OK
	#swcert = 3 ==> Cert test and it's expired

	if ( $swcert < 1 )
	{
		### Starting Farms
		&printAndLog( "* Starting Farms:\n" );
		my @farmsf = &getFarmList();

		foreach my $ffile ( @farmsf )
		{
			my $farmname = &getFarmName( $ffile );
			my $bstatus  = &getFarmBootStatus( $farmname );

			if ( $bstatus eq "up" )
			{
				&printAndLog( "  * Starting Farm $farmname:" );
				my $status = &_runFarmStart( $farmname, "false" );

				if ( $status == 0 )
				{
					&printAndLog( " \033[1;32m OK \033[0m \n" );
				}
				else
				{
					&printAndLog( " \033[1;31m ERROR \033[0m \n" );
				}

				#farmguardian configured and up?
				my $fgstatus = &getFarmGuardianStatus( $farmname );

				if ( ( $status == 0 ) && ( $fgstatus == 1 ) && $allow_fg )
				{
					&printAndLog( "  * Starting Farm Guardian for $farmname:" );
					my $stat = &runFarmGuardianStart( $farmname, "" );

					if ( $stat == 0 )
					{
						&printAndLog( " \033[1;32m OK \033[0m \n" );
					}
					else
					{
						&printAndLog( " \033[1;31m ERROR \033[0m \n" );
					}
				}
			}
			else
			{
				&printAndLog( "  Farm $farmname configured DOWN\n" );
			}
		}

		#At this point every zen interfaces and farms are running
		#now a personalized script can be executed
		my @ownscript = `$configdir/zlb-start 2>&1`;

		&zenlog("Starting $configdir/zlb-start...");
		if ( @ownscript )
		{
			print "@ownscript";
			&zenlog("@ownscript");
		}
		&zenlog("End of $configdir/zlb-start...");
	}
	else
	{
		&printAndLog( "No valid ZLB certificate was found, no farm started\n" );
	}

	# start cluster
	if ( &getZClusterStatus() )
	{
		&enableAllInterfacesDiscovery();
		&enableZCluster();
	}

	# related system services
	if ( system( "/etc/init.d/ssh status >/dev/null 2>&1" ) )
	{
		system( "/etc/init.d/ssh start >/dev/null 2>&1" );
	}

	&local_http_service('start');

	&zenlog( "start proccess finished" );
}

if ( $eject eq "stop" )
{
	require "/usr/local/zenloadbalancer/www/blacklists.cgi";
	require "/usr/local/zenloadbalancer/www/notifications.cgi";
	require "/usr/local/zenloadbalancer/www/dos.cgi";

	&zenlog( "Beginning stop proccess" );

	# stop all modules
	&zlbstopNotifications( );
	&setBLStop();
	&setDOSStop();

	if ( &getZClusterStatus() )
	{
		&zenlog( "Stopping ZCluster...\n" );

		if ( `pgrep zeninotify` )
		{
			my $zenino = &getGlobalConfiguration('zenino');
			system ( "$zenino stop" );
		}

		if ( &getZClusterRunning() )
		{
			&disableZCluster();
		}
	}

	&printAndLog( "Stopping ZEVENET Load Balancer...\n" );

	### Stopping Farms
	&printAndLog( "* Stopping Farms:\n" );

	my @farmsf = &getFarmList();

	foreach my $ffile ( @farmsf )
	{
		my $farmname = &getFarmName( $ffile );
		my $status   = &getFarmStatus( $farmname );

		if ( $status eq "up" )
		{
			#farmguardian configured and up?
			my $fgstatus = &getFarmGuardianPid( $farmname );

			if ( $fgstatus != -1 )
			{
				&printAndLog( "  * Stopping Farm Guardian for $farmname:" );
				my $stat = &runFarmGuardianStop( $farmname, "" );

				if ( $stat == 0 )
				{
					&printAndLog( " \033[1;32m OK \033[0m \n" );
				}
				else
				{
					&printAndLog( " \033[1;31m ERROR \033[0m \n" );
				}
			}
			&printAndLog( "  * Stopping Farm $farmname:" );
			my $status = &_runFarmStop( $farmname, "false" );

			if ( $status == 0 )
			{
				&printAndLog( " \033[1;32m OK \033[0m \n" );
			}
			else
			{
				&printAndLog( " \033[1;31m ERROR \033[0m \n" );
			}
		}
	}

	### Stopping Network Interfaces
	&printAndLog( "* Stopping Interfaces:\n" );

	# First Virtual Network Interfaces
	foreach my $iface ( @configured_interfaces )
	{
		if ( $$iface{ vini } ne '' )
		{
			&printAndLog( "  * Down interface $$iface{name}\n" );
			&printAndLog( "    Ip:$$iface{addr} Netmask:$$iface{mask}" );

			my $return_code = &stopIf( $iface );

			if ( $return_code == 0 )
			{
				&printAndLog( " \033[1;32m OK \033[0m \n" );
			}
			else
			{
				&printAndLog( " \033[1;31m ERROR \033[0m \n" );
			}
		}
	}

	&enableAllInterfacesDiscovery() if $zcl_configured;

	#At this point all zen interfaces and farms are stopped
	#now a personalized script can be executed
	my @ownscript = `$configdir/zlb-stop 2>&1`;

	&zenlog("Starting $configdir/zlb-stop...");
	if ( @ownscript )
	{
		print "@ownscript";
		&zenlog("@ownscript");
	}
	&zenlog("End of $configdir/zlb-stop...");

	&zenlog( "Stop process finished..." );
}

&configureDefaultGW();
