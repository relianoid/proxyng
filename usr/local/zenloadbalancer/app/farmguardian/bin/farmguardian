#!/usr/bin/perl 

###############################################################################
#
#     Zen Load Balancer Software License
#     This file is part of the Zen Load Balancer software package.
#
#     Copyright (C) 2014 SOFINTEL IT ENGINEERING SL, Sevilla (Spain)
#
#     This library is free software; you can redistribute it and/or modify it
#     under the terms of the GNU Lesser General Public License as published
#     by the Free Software Foundation; either version 2.1 of the License, or
#     (at your option) any later version.
#
#     This library is distributed in the hope that it will be useful, but
#     WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
#     General Public License for more details.
#
#     You should have received a copy of the GNU Lesser General Public License
#     along with this library; if not, write to the Free Software Foundation,
#     Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
###############################################################################

##farmguardian 1.0
#this script is a service that check all Bakends or servers in a farm
#using a script to monitorice the status of backends.  If the execution script return
# <> 0 this script put in blacklist the backendserver. This script check
#the timeout execution of a script
#parameters:
#
#	>./farmguardian farmname [-s <service>] [-l]
#
#fileconfig_penguardian structure:
#[farmname]:::[timeout]:::[timetocheck]:::[script args]:::[logs]

use Proc::Daemon;
use POSIX( WNOHANG );

require '/usr/local/zenloadbalancer/config/global.conf';
require '/usr/local/zenloadbalancer/www/functions.cgi';

# print usage help if no argument was given
if ( $ARGV[0] eq "" )
{
	print
	  "FarmGuardian V3.0. Check Backends Servers in a Farm and enable or disable the load balancing\n";
	print "	help: farmguardian farmname [-s <service>] [-l]\n";
	print
	  "		-s <service>	: Launch FarmGuardian for a certain HTTP/S farm service\n";
	print "		-l 		: Active logs in $farmguardian_logs directory\n";

	exit 0;
}

# declare global variables
my $service;
my $fservice;

# handle service argument
if ( $ARGV[1] eq "-s" )
{
	$service  = $ARGV[2];
	$fservice = "${service}_";
}

# declare config files/path
my $pidfile    = $ARGV[0] . "_${fservice}guardian.pid";
my $file       = $ARGV[0] . "_${fservice}guardian.conf";
my $fileconfig = "$configdir/$file";

# handle log argument
if ( $ARGV[1] eq "-l" || $ARGV[3] eq "-l" )
{
	open STDERR, '>>', "$farmguardian_logs/$ARGV[0]_${fservice}farmguardian.log"
	  or die;
	open STDOUT, '>>', "$farmguardian_logs/$ARGV[0]_${fservice}farmguardian.log"
	  or die;
}
else
{
	open STDERR, '>>', "/dev/null" or die;
	open STDOUT, '>>', "/dev/null" or die;
}

# abort if $fileconfig does not exist
if ( !-e $fileconfig )
{
	print "Abort: file $fileconfig not found\n";
	exit -1;
}

# read configuration file
open FI, "$fileconfig";
while ( <FI> )
{
	$line = $_;
}
close FI;

# $line have the last line in a file
my @args          = split ( ":::", $line );
my $farmname      = @args[0];
my $timetocheck   = @args[1];
my $check_cmd_tpl = @args[2];
my $enabled       = @args[3];

# check if the service is enabled in the current farm
if ( $enabled ne "true" )
{
	print "FarmGuardian is $enabled in the farm $farm - $service\n";
	exit 0;
}

# create farmgardian pidfile
my $filepid = "/var/run/$pidfile";
open FO, "> $filepid";
print FO "$$";
close FO;

#Ask for the farm type
my $type = &getFarmType( $farmname );

#Get the admin port/socket about farm
my $portadmin = &getFarmPort( $farmname );

#Get servers list
while ( 1 )
{
	# Check if the log file exists
	$filesize = -s "$farmguardian_logs/$ARGV[0]_${fservice}farmguardian.log";
	if (
		 (
		   ( $ARGV[1] eq "-l" || $ARGV[3] eq -l )
		   && !( -e "$farmguardian_logs/$ARGV[0]_${fservice}farmguardian.log" )
		 )
		 || ( $filesize == 0 )
	  )
	{
		print "$farmguardian $fservice log doesn't exist, creating now...\n";
		close STDERR;
		close STDOUT;
		open STDERR, '>>', "$farmguardian_logs/$ARGV[0]_${fservice}farmguardian.log"
		  or die;
		open STDOUT, '>>', "$farmguardian_logs/$ARGV[0]_${fservice}farmguardian.log"
		  or die;
	}

	### Collect variable values for the diferent farm types ###

	# Collect TCP/UDP farm variables values
	if ( $type eq "tcp" || $type eq "udp" )
	{
		my @run = `$pen_ctl 127.0.0.1:$portadmin servers`;
		$errorcode = $?;
		if ( $errorcode != 0 )
		{
			print "Farm $farmname is down, abort.\n";
			exit 1;
		}
		$i = 0;
		foreach $line ( @run )
		{
			@lines = split ( "\ ", $line );
			if ( @lines[2] ne "0.0.0.0" )
			{
				@backendid[$i]   = @lines[0];
				@backendserv[$i] = @lines[2];
				@backendport[$i] = @lines[4];
				$i++;
			}
		}
	}

	# Collect HTTP/S farm variables values
	elsif ( $type eq "http" || $type eq "https" )
	{
		my @run = `$poundctl -c $portadmin`;
		$errorcode = $?;
		if ( $errorcode != 0 )
		{
			print "Farm $farmname is down, abort.\n";
			exit 1;
		}

		my $backendsvs = &getFarmVS( $farmname, $service, "backends" );

		#print "--> BACKENDS: \n$backendsvs";
		my @be = split ( "\n", $backendsvs );
		$i = 0;
		foreach my $line ( @be )
		{
			my @subbe = split ( "\ ", $line );
			@backendid[$i]     = @subbe[1];
			@backendserv[$i]   = @subbe[3];
			@backendport[$i]   = @subbe[5];
			@backendstatus[$i] = &getHTTPBackendStatusFromFile( $farmname, $i, $service );

#print "--> DATA:\n $i @backendid[$i] @backendserv[$i] @backendport[$i] @backendstatus[$i]\n";
			$i++;
		}
	}

	# Collect L4xNAT farm variables values
	elsif ( $type eq "l4xnat" )
	{
		my @be = &getFarmBackendStatusCtl( $farmname );
		$i = 0;
		foreach my $line ( @be )
		{
			my @subbe = split ( ";", $line );
			@backendid[$i]     = $i;
			@backendserv[$i]   = @subbe[2];
			@backendport[$i]   = @subbe[3];
			@backendstatus[$i] = @subbe[7];
			$i++;
		}
	}

	# pick up the farm's timeout
	if ( $type eq "tcp" || $type eq "udp" )
	{
		$timeout = `$pen_ctl 127.0.0.1:$portadmin timeout`;
		chomp ( $timeout );

		$blacklist = `$pen_ctl 127.0.0.1:$portadmin blacklist`;
		chomp ( $blacklist );
	}
	elsif ( $type eq "http" || $type eq "https" )
	{
		$timeout = &getFarmTimeout( $farmname );
	}

	#~ elsif ( $type eq "l4xnat" )
	#~ {
	#~ 	# l4xnat does not have timeout check Â¿?
	#~ }

	# Use the default timetocheck as the timeout for the backends response
	if ( $timeout eq "" )
	{
		$timeout = $timetocheck;
	}
	print "The servers timeout is: $timeout\n";

	my $j = 0;

	# print farmguardian parameters for this farm
	if ( $ARGV[1] eq "-l" || $ARGV[3] eq "-l" )
	{
		print "	checking:\n";
		print "		farmname: $farmname\n";
		print "		timeout: $timeout\n";
		print "		blacklist: $blacklist\n";
		print "		timetocheck: $timetocheck\n";
		print "		portadmin: $portadmin\n";

		while ( $j < $i )    # $i is the NumberOfBackends-1
		{
			print "		server[@backendid[$j]]: @backendserv[$j]:@backendport[$j]\n";
			$j++;
		}

		print "		check: $check_cmd_tpl\n";
		print "\n";
		my $now = localtime time;
		print "execution in $now ::\n";
	}

	# initialize $j to prepare the backend's loop
	my $j = 0;

	# backend loop. checking every backend.
  BACKEND_IDX:
	while ( $j < $i )    # $i is the NumberOfBackends-1
	{
		if ( $ARGV[1] eq "-l" || $ARGV[3] eq "-l" )
		{
			print "		server[@backendid[$j]]: @backendserv[$j]:@backendport[$j]\n";
		}
		print "Backend status $j: @backendstatus[$j]\n";

		# jump to next backend if this one is in maintenance
		if ( @backendstatus[$j] =~ /maintenance/ )
		{
			$j++;
			next BACKEND_IDX;
		}

		my $check_cmd = $check_cmd_tpl;

		# substitute HOST and PORT variables for this backend's values
		$check_cmd =~ s/HOST/$backendserv[$j]/;
		$check_cmd =~ s/PORT/$backendport[$j]/;

		#execute the binary to check
		#my $command = "adb shell cd /data/app; ./iperf -u -s -p 5001";
		my $command = "$libexec_dir/$check_cmd";

		#print "executing: $command\n";
		my @output;
		my $timedout = 0;

		# run actual backend check
		eval {
			local $SIG{ ALRM } = sub { die "Timeout\n" };
			alarm $timeout;
			print "command: $command\n";
			@output    = `$command`;
			$errorcode = $?;
			alarm 0;
		};

		# control check eval outcome if failed
		if ( $@ )
		{
			warn "$command timed out.\n";
			$timedout = 1;
			do
			{
				my $kid = waitpid ( -1, WNOHANG );

				#print "pid $kid exited\n";
			} while $kid > 0;
		}

		# being verbose the check output
		if ( $ARGV[1] eq "-l" )
		{
			print "timedout: $timedout \n";
			print "errorcode: $errorcode \n";
		}

		### Enable backend
		if ( $timedout == 0 && $errorcode == 0 && @backendstatus[$j] =~ /down/i )
		{
			if ( $ARGV[1] eq "-l" )
			{
				print
				  "**execution OK in server $j\nerrorcode: $errorcode\ntimedout: $timedout\nbackend state: @backendstatus[$j]\n";
			}

			# Enabling backend for every type of farm supported
			if ( $type eq "tcp" || $type eq "udp" )
			{
				my $run = `$pen_ctl 127.0.0.1:$portadmin server $j blacklist 0`;
			}
			elsif ( $type eq "http" || $type eq "https" )
			{
				my $idsv = &getFarmVSI( $farmname, $service );
				my $run = `$poundctl -c $portadmin -B 0 $idsv $j`;
				&getFarmHttpBackendStatus( $farmname, $j, "active", $idsv );
			}
			elsif ( $type eq "l4xnat" )
			{
				&setFarmBackendStatus( $farmname, $j, "up" );
			}

			@backendstatus[$j] = "active";
		}
		### Disable backend
		elsif (
				( ( $timedout != 0 || $errorcode != 0 ) && @backendstatus[$j] ne "fgDOWN" )
				|| (    ( $timedout != 0 || $errorcode != 0 )
					 && @backendstatus[$j] eq "fgDOWN"
					 && $type eq "tcp" )
		  )
		{
			if ( $ARGV[1] eq "-l" || $ARGV[3] eq "-l" )
			{
				print "**execution error in ' $command ', output::**\n", @output;
			}

			# Disabling backend for every type of farm supported
			#if exec error put in blacklist the server
			if ( $type eq "tcp" || $type eq "udp" )
			{
				my $run = `$pen_ctl 127.0.0.1:$portadmin server $j blacklist $blacklist`;
			}
			elsif ( $type eq "http" || $type eq "https" )
			{
				my $idsv = &getFarmVSI( $farmname, $service );
				my $run = `$poundctl -c $portadmin -b 0 $idsv $j`;
				&getFarmHttpBackendStatus( $farmname, $j, "fgDOWN", $idsv );
				&setFarmBackendsSessionsRemove( $farmname, $service, $j );
			}
			elsif ( $type eq "l4xnat" )
			{
				&setFarmBackendStatus( $farmname, $j, "fgDOWN" );
			}

			@backendstatus[$j] = "fgDOWN";
		}
		else
		{
			print "No state changed for the backend.\n";
		}

		$j++;
	}
	sleep ( $timetocheck );
}

