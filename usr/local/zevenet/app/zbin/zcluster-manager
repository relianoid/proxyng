#!/usr/bin/perl 
###############################################################################
#
#    Zevenet Software License
#    This file is part of the Zevenet Load Balancer software package.
#
#    Copyright (C) 2014-today ZEVENET SL, Sevilla (Spain)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

## zcluster-manager 1.0
#
# Usage:
#
# zcluster-manager enableZCluster
# zcluster-manager disableZCluster
# zcluster-manager setKeepalivedConfig
# zcluster-manager setConntrackdConfig
# zcluster-manager getZClusterRunning
# zcluster-manager getZClusterNodeStatus
# zcluster-manager getConntrackdRunning
# zcluster-manager getZClusterArpStatus
# zcluster-manager sync
# zcluster-manager notify_master
# zcluster-manager notify_backup
# zcluster-manager notify_fault
#
# zcluster-manager interface float-update
# zcluster-manager interface start <interface> [4|6]
# zcluster-manager interface stop <interface> [4|6]
# zcluster-manager interface delete <interface> [4|6]
#
# zcluster-manager gateway update <interface> [4|6]
# zcluster-manager gateway delete <interface> [4|6]
#
# zcluster-manager farm start <farm>
# zcluster-manager farm stop <farm>
# zcluster-manager farm restart <farm>
# zcluster-manager farm delete <farm>
#
# zcluster-manager ipds bl
# zcluster-manager ipds dos
# zcluster-manager ipds rbl
#

use strict;
use warnings;
use feature 'say';
use Zevenet::Log;
use Zevenet::Debug;

#~ my $primary_backup = "/usr/share/doc/conntrackd/examples/sync/primary-backup.sh";

&zenlog( "ARGV:@ARGV" ) if &debug();

my $object = shift @ARGV // '';
my $command = shift @ARGV // '';

if ( ! grep { $object eq $_ } ( qw(interface gateway farm ipds) ) )
{
	if ( $object =~ /Conntrackd/ )
	{
		require Zevenet::Conntrackd;
	}
	else
	{
		require Zevenet::Cluster;
	}
}

#~ if ( $object eq 'node' )
#~ {
if ( $object eq 'enableZCluster' )
{
	exit &enableZCluster();
}
elsif ( $object eq 'disableZCluster' )
{
	exit &disableZCluster();
}
elsif ( $object eq 'setKeepalivedConfig' )
{
	exit &setKeepalivedConfig();
}
elsif ( $object eq 'setConntrackdConfig' )
{
	exit &setConntrackdConfig();
}
elsif ( $object eq 'getZClusterRunning' )
{
	#~ say &getZClusterRunning();
	say ( ( &getZClusterRunning() )? '1': '0' );
	#~ say ( &getZClusterRunning() )? 'true': 'false';
	exit 0;
}
elsif ( $object eq 'getZClusterNodeStatus' )
{
	say &getZClusterNodeStatus();
	exit 0;
}
elsif ( $object eq 'getConntrackdRunning' )
{
	#~ say &getConntrackdRunning();
	say ( ( &getConntrackdRunning() )? '1': '0' );
	exit 0;
}
elsif ( $object eq 'getZClusterArpStatus' )
{
	my $status;

	if ( ! &getZClusterRunning() )
	{
		say 'ko';
		exit 0;
	}

	my $node_role = &getZClusterNodeStatus();
	my @arptables_lines = `arptables -L INPUT`;

	for my $if_ref ( &getInterfaceList() )
	{
		next if $if_ref->{ vini } eq ''; # only virtual ips

		my $if_dropped = grep { $_ =~ /^-j DROP -d $if_ref->{ addr } $/ } @arptables_lines;

		if ( $node_role ne 'master' && !$if_dropped )
		{
			$status = 'ko';
			last;
		}
		elsif ( $node_role eq 'master' && $if_dropped )
		{
			$status = 'ko';
			last;
		}
	}

	if ( $status ne 'ko' )
	{
		$status = 'ok';
	}
	
	say $status;
	exit 0;
}
elsif ( $object eq 'sync' )
{
	my $configdir = &getGlobalConfiguration('configdir');
	my $rttables = &getGlobalConfiguration('rttables');

	&zenlog("Syncing $configdir");
	&runSync( $configdir );

	&zenlog("Syncing $rttables");
	&runSync( $rttables );
}
elsif ( $object eq 'notify_master' )
{
	exit &setNodeStatusMaster();
}
elsif ( $object eq 'notify_backup' )
{
	exit &setNodeStatusBackup();
}
elsif ( $object eq 'notify_fault' )
{
	exit &setNodeStatusMaintenance();
}
#~ }


# farm commands
if ( $object eq 'farm' )
{
	require Zevenet::Farm::Action;

	if ( $command eq 'start' )
	{
		my $farm_name = shift @ARGV;
		&quit("Missing farm name argument") if ! $farm_name;

		my $status = &_runFarmStart( $farm_name );

		# reload ipds rules
		require Zevenet::IPDS::Blacklist;
		require Zevenet::IPDS::DoS;
		require Zevenet::IPDS::RBL;
		&runBLStopModule();
		&runBLStartModule();
		&runDOSStopModule();
		&runDOSStartModule();
		&runRBLStartByFarm( $farm_name );

		exit $status;
	}
	elsif ( $command eq 'stop' )
	{
		my $farm_name = shift @ARGV;
		&quit("Missing farm name argument") if ! $farm_name;

		# reload ipds rules
		require Zevenet::IPDS::Blacklist;
		require Zevenet::IPDS::DoS;
		require Zevenet::IPDS::RBL;
		
		&runBLStopModule();
		&runBLStartModule();
		&runDOSStopModule();
		&runDOSStartModule();
		&runRBLStopByFarm( $farm_name );

		exit &_runFarmStop( $farm_name );
	}
	elsif ( $command eq 'restart' )
	{
		my $farm_name = shift @ARGV;
		&quit("Missing farm name argument") if ! $farm_name;

		# include ipds rules
		require Zevenet::IPDS::Blacklist;
		require Zevenet::IPDS::DoS;
		require Zevenet::IPDS::RBL;
		
		&runBLStopModule();
		&runDOSStopModule();
		&runRBLStopByFarm( $farm_name );

		&_runFarmStop( $farm_name );
		my $status = &_runFarmStart( $farm_name );

		&runBLStartModule();
		&runDOSStartModule();
		&runRBLStartByFarm( $farm_name );

		exit $status;
	}
	elsif ( $command eq 'delete' )
	{
		my $farm_name = shift @ARGV;
		&quit("Missing farm name argument") if ! $farm_name;

		exit &runFarmDelete( $farm_name );
	}
	else
	{
		&quit("Unrecognized farm command");
	}
}

# farm commands
if ( $object eq 'ipds' )
{
	# Get params
	my $action;
	my $module;
	my $farmname;
	my $rule;
	my $farmname_re = &getValidFormat( 'farm_name' );

	# command = "module_action_rule,farmname"
	if ( $command =~ /([a-zA-Z]+)_(rbl|bl|dos)(_\w+(,$farmname_re)?)?/ )
	{
		$action = $1;
		$module = $2;
		my $opt = $3;
		if ( $opt )
		{
			$opt =~ s/^_//;
			if ( $opt =~ /,/ )
			{
				( $rule, $farmname ) = split ( ',', $opt );
			}
			else
			{
				$rule = $opt;
			}
			
		}
	}
	
	if ( $module eq 'bl' )
	{
		require Zevenet::IPDS::Blacklist;

		# reload blacklist rules
		&runBLStopModule();
		&runBLStartModule();

		exit 0;
	}
	elsif ( $module eq 'dos' )
	{
		require Zevenet::IPDS::DoS;

		# reload DoS rules
		&runDOSStopModule();
		&runDOSStartModule();

		exit 0;
	}
	elsif ( $module eq 'rbl' )
	{
		require Zevenet::IPDS::RBL;

		if ( $farmname )
		{
			# stop RBL rules
			if ( $action eq "stop" )
			{
				&runRBLStop( $rule, $farmname );
			}
			# start RBL rules
			elsif ( $action eq "start" )
			{
				&runRBLStart( $rule, $farmname );
			}
			# reload RBL rules
			else
			{
				&runRBLRestart( $rule, $farmname );
			}
		}
		elsif ( $rule )
		{
			# stop RBL rules
			if ( $action eq "stop" )
			{
				&runRBLStopByRule( $rule );
			}
			# start RBL rules
			elsif ( $action eq "start" )
			{
				&runRBLStartByRule( $rule );
			}
			# reload RBL rules
			else
			{
				&runRBLRestartByRule( $rule );
			}
		}
		else
		{
			# stop RBL rules
			if ( $action eq "stop" )
			{
				&runRBLStopModule();
			}
			# start RBL rules
			elsif ( $action eq "start" )
			{
				&runRBLStartModule();
			}
			# reload RBL rules
			else
			{
				&runRBLRestartModule();
			}
		}

		exit 0;
	}

	else
	{
		&quit("Unrecognized ipds command");
	}
}

# interface commands
# WARNING: only virtual interfaces are handled
if ( $object eq 'interface' )
{
	require Zevenet:Net;

	if ( $command eq 'float-update' )
	{
		&reloadL4FarmsSNAT();
		exit 0;
	}

	# common interface initial tasks
	my $if_name = shift @ARGV;		# virtual interface name
	my $ip_v = shift @ARGV // 4;	# ip version: 4 or 6 (default: 4)

	# must have an interface argument
	&quit( "Interface action not defined." ) if ! $if_name;
	&quit( "Only virtual interfaces are supported." ) if $if_name !~ /.+:.+/;	# only accept virtual interfaces

	my $if_ref = &getInterfaceConfig( $if_name, $ip_v );

	exit 1 if ! $if_ref;

	my $status;

	# define different interface actions

	# configures ip
	if ( $command eq 'start' )
	{
		&disableInterfaceDiscovery( $if_ref ); # backup node only
		$status = &addIp( $if_ref );
		$status = &applyRoutes( "local", $if_ref ) if $status == 0;
		&reloadL4FarmsSNAT();
		exit $status;
	}
	elsif ( $command eq 'stop' ) # flush ip
	{
		$status = &delIp( $$if_ref{ name }, $$if_ref{ addr }, $$if_ref{ mask } );
		&reloadL4FarmsSNAT();
		&enableInterfaceDiscovery( $if_ref );
		exit $status;
	}
	elsif ( $command eq 'delete' ) # remove interface stats and other
	{
		$status = &delIf( $if_name );
		exit $status;
	}
}

if ( $object eq 'gateway' )
{
	my $iface_name = shift @ARGV;
	my $ip_version = shift @ARGV;

	require Zevenet:Net;

	my $status;
	
	if ( $command eq 'update' )
	{
		my $if_ref = getInterfaceConfig( $iface_name, $ip_version );

		exit 1 if ! $if_ref;
		
		$status = &applyRoutes( "global", $if_ref, $if_ref->{ gateway } );
		&reloadL4FarmsSNAT();
		
		exit $status;
	}
	elsif ( $command eq 'delete' ) # remove interface stats and other
	{
		my $defaultgwif = &getGlobalConfiguration('defaultgwif');
		my $if_ref = getInterfaceConfig( $defaultgwif, $ip_version );

		exit 1 if ! $if_ref;

		$status = &delRoutes( "global", $if_ref );
		exit $status;
	}
}


# "GROUP"|"INSTANCE"
#~ elsif ( $ARGV[0] eq 'GROUP' || $ARGV[0] eq 'INSTANCE' )
#~ {
    #~ # $1 = "GROUP"|"INSTANCE"
    #~ # $2 = name of the group or instance
    #~ # $3 = target state of transition
    #~ #     ("MASTER"|"BACKUP"|"FAULT")
    #~ # $4 = Node priority
#~ 
	#~ my %notif = (
				  #~ type   => $ARGV[0],
				  #~ name   => $ARGV[1],
				  #~ target => $ARGV[2],
				  #~ prio   => $ARGV[3],
	#~ );
#~ 
	#~ my $target_state = $ARGV[2];
#~ 
	#~ if ( $notif{ target } eq 'MASTER' )
	#~ {
		#~ # &setNodeStatusMaster();
	#~ }
	#~ elsif ( $notif{ target } eq 'BACKUP' )
	#~ {
		#~ # &setNodeStatusBackup();
	#~ }
	#~ elsif ( $notif{ target } eq 'FAULT' )
	#~ {
		#~ # &setNodeStatusBackup();
	#~ }
#~ }
elsif ( @ARGV == 0 )
{
	# FIXME: do something??
}



sub setNodeStatusMaster
{
	if ( &getZClusterNodeStatus() eq 'master' )
	{
		&zenlog("Node is already master");
		return 0;
	}

	&zenlog("Switching node to master");
	&setZClusterNodeStatus('master');

	my $primary_backup = &getGlobalConfiguration('primary_backup');
	system("$primary_backup primary");

	# flush arp rules
	my $rc = &enableAllInterfacesDiscovery();

	# announce ips ( arp and neigh )
	my @configured_interfaces = @{ &getConfigInterfaceList() };
	#~ &zenlog("Found candidate for GArping $_->{ name }, $_->{ addr }") for @configured_interfaces;
	
	for my $if_ref ( @configured_interfaces )
	{
		next if $if_ref->{ vini } eq '';
		
		&broadcastInterfaceDiscovery( $if_ref );
	}
	
	# start sync
	my $zenino = &getGlobalConfiguration('zenino');
	system( "$zenino &" );

	# start farmguardians
	my @farmsf = &getFarmList();

	foreach my $ffile ( @farmsf )
	{
		my $farmname = &getFarmName( $ffile );
		my $bstatus  = &getFarmBootStatus( $farmname );

		if ( $bstatus eq "up" )
		{
			#~ print "  * Starting Farm $farmname:";
			#~ $status = &_runFarmStart( $farmname, "false" );

			#farmguardian configured and up?
			my $fgstatus = &getFarmGuardianStatus( $farmname );

			if ( ( $bstatus == 'up' ) && ( $fgstatus == 1 ) )
			{
				my $error_code = &runFarmGuardianStart( $farmname, "" );
				if ( $error_code )
				{
					&zenlog("Some error happened starting farmguardian for farm $farmname");
				}
			}
		}
	}

	return 0;
}

sub setNodeStatusBackup
{
	if ( &getZClusterNodeStatus() eq 'backup' )
	{
		&zenlog("Node is already backup");
		#~ return 0;
	}
	else
	{
		&zenlog("Switching node to backup");
		&setZClusterNodeStatus('backup');
	}

	my $primary_backup = &getGlobalConfiguration('primary_backup');
	system("$primary_backup backup");

	my $zenino = &getGlobalConfiguration('zenino');
	system( "$zenino stop &" ) unless system('pgrep zeninotify.pl');

	# stop farmguardians
	system("pkill `pgrep farmguardian`");

	# block/disable ip announces ( arp and neigh )
	my @configured_interfaces = @{ &getConfigInterfaceList() };
	for my $if_ref ( @configured_interfaces )
	{
		next if $if_ref->{ vini } eq '';
		&disableInterfaceDiscovery( $if_ref );
	}

	return 0;
}

sub setNodeStatusMaintenance
{
	if ( &getZClusterNodeStatus() eq 'maintenance' )
	{
		&zenlog("Node is already under maintenance");
		return 0;
	}
	else
	{
		&zenlog("Switching node to under maintenance");
		&setZClusterNodeStatus('maintenance');
	}

	my $primary_backup = &getGlobalConfiguration('primary_backup');
	system("$primary_backup fault");

	my $zenino = &getGlobalConfiguration('zenino');
	system( "$zenino stop &" ) unless system('pgrep zeninotify.pl');

	# stop farmguardian
	system("pkill `pgrep farmguardian`");

	# block/disable ip announces ( arp and neigh )
	my @configured_interfaces = @{ &getConfigInterfaceList() };
	for my $if_ref ( @configured_interfaces )
	{
		next if $if_ref->{ vini } eq '';
		&disableInterfaceDiscovery( $if_ref );
	}

	return 0;
}

sub quit
{
	my $msg = shift;

	if ( $msg )
	{
		&zenlog( $msg );
		print "$msg\n";
	}

	exit 1;
}

#~ &zenlog( `grep RSS /proc/$$/status` );
