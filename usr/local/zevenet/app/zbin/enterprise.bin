#!/usr/bin/perl
###############################################################################
#
#    Zevenet Software License
#    This file is part of the Zevenet Load Balancer software package.
#
#    Copyright (C) 2014-today ZEVENET SL, Sevilla (Spain)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;

use Time::Local;
use Zevenet::Log;
use Zevenet::Debug;
use Zevenet::Config;

my $DEBUG    = &debug();
my $SYMKEY   = "1135628147310";
my $lib_path = '/usr/share/perl5';
my $module   = shift @ARGV;
my $basename = ( split ( '/', $0 ) )[-1];

# Run encrypted command
if ( $basename ne 'enterprise.bin' )
{
	$basename =~ s!\.(?:pl|cgi)$!!; # Remove trailing .pl or .cgi if exists

	if ( $basename eq 'zapi' )
	{
		my $api_ver = ( split ( '/', $0 ) )[-2]; # get zapi.cgi directory name
		$basename = "$basename-$api_ver"; # add version. E.g.: 'zapi-v3'
	}

	my $mod = "Zevenet::Cmd::$basename";

	if ( $DEBUG )
	{
		my $msg = '';

		$msg = "enterprise.bin called: $0";
		#~ &zenlog( $msg );
		say( $msg );

		$msg = "enterprise.bin basename: $basename";
		say( $msg );

		$msg = "Module: $mod";
		#~ &zenlog( $msg );
		say( $msg );
	}

	&include( $mod );
	exit;
}

require Zevenet::Validate;
require Zevenet::SystemInfo;

# check module name provided
unless ( $module )
{
	print STDERR "enterprise.bin: missing operand
Try 'enterprise.bin --help' for more information.\n";

	exit 1;
}

# command help and usage instructions
if ( $module =~ /^(?:-h|-help|--help)$/ )
{
	print "Usage: enterprise.bin MODULE [FUNCTION]
Decrypt Zevenet Enterprise Edition Module.

Example:\tenterprise.bin Zevenet::API31::System::Cluster get_cluster < JSONFILE

Run encrypted module accepting arguments from STDIN in JSON format, returning JSON output.
";

	exit 0;
}



## Required conditions

# check function name provided
my $func = shift @ARGV;
unless ( $func )
{
	die "$0: No API function name received.";
}



## Activation certificate

# check if the activation certificate is valid
my $hostname = &getHostname();
my $basedir  = &getGlobalConfiguration('basedir');

my $skip_cert_check = (    $module =~ /Zevenet::API3\d::Certificate::Activation/
						&& $func   eq 'upload_activation_certificate' );

unless ( $skip_cert_check )
{
	my $swcert = &certcontrol();

	if ( $swcert > 0 )
	{
		die "$0: Invalid activation certificate ($swcert)";
	}
}



## Module. Find, decrypt and load the module

# validate module
my $mod_path = "$lib_path/$module.pm";
$mod_path =~ s#\:\:#\/#g; # Replace :: with /
my $emod_path = "${mod_path}e";

my $code;

if ( -f $mod_path )
{
	$code = `cat ${mod_path}`;
}
elsif ( -f $emod_path )
{
	my $cmd = "openssl aes-256-cbc -d -a -nosalt -k \"${SYMKEY}\" -in ${emod_path}";
	$cmd .= " -md md5" if `uname -r` =~ /^4.9/;

	$code = `$cmd`;
}
else
{
	my $msg = "Module file $module not found.";
	&zenlog( $msg );
	die $msg;
}

# load module
eval $code;

if ( $@ )
{
	&zenlog( "### Module path:   $mod_path" );
	&zenlog( "### E-Module path: $emod_path" );
	&zenlog( "### Module name:   $module" );
	&zenlog( $@ );
	die $@;
}



## Function. Check the function is in the module, load params from input in JSON

# check if the function is available
unless ( grep { /^sub $func(?:\W|$)/ } split( '\n', $code ) )
{
	die "$0: API function $func definition not found";
}



# Arguments. Passed from STDIN as a JSON string
# Load Input, then Decode JSON from intput string

# get input for api function
my $input;
{
	local $/ = undef;
	$input = <STDIN>;
}

# my $input_l = length $input;
# unless ( $input_l >= 2 )
# { &zenlog("Function args input length: Not enough characters. Failed!" ); }
# &zenlog( "#### Function input: $input" ) if $input ne '["1"]';

# decode JSON
require Zevenet::API31::HTTP;
require JSON;
JSON->import();

# decode input into data reference
my $args;
if ( eval { $args = decode_json( $input ); } )
     { 1 || &zenlog( "#### Function input JSON decode: [OK]" ); } ####
else { &zenlog( "#### Function input JSON decode: Failed!" ); } ####



## Run call

# make code reference from function name
my $code_ref = \&{ $func };
my $returned_value;

# call api request function
eval { $returned_value = [ $code_ref->( @{ $args } ) ] };
if ( $@ )
{
	&zenlog( "#### Function run $func: Failed!" );
	&zenlog( $@ );
	die $@;
}

unless ( defined $returned_value ) { &zenlog( "#### Function output defined: Failed!" ); } ####

my $output = '';

if ( ref $returned_value )
{
	## Proccess output

	# Encode output in JSON and print it
	my $json = JSON->new();

	#~ unless ( eval { $json_out = encode_json( $returned_value ); } )
	unless ( eval { $output = $json->pretty->indent->canonical->encode( $returned_value ); } )
	{ &zenlog( "#### Function output JSON encode: Failed!" ); }

	# Optionally send JSON to system log
	#~ &zenlog( "json: '$_'" ) for split ( /\\n/, $output );
}
else
{
	$output = $returned_value;
}

# Send Output to STDOUT
print $output;

# Send memory usage info to system log
if ( &debug() )
{
	my $msg = "MODULE: $module FUNCTION: $func " . &getMemoryUsage();

	&zenlog( $msg );
}

exit 0;


=begin nd
Function: include

	Load Enterprise module, encrypted or not.


	Variable			Example
	------------------------------------
	$mod_space			Zevenet::Debug
	$mod_path			Zevenet/Debug
	$mod_key			Zevenet/Debug.pme
	$mod_fullpath		/usr/share/perl5/Zevenet/Debug.pme


	Example %INC:
	{
		'Zevenet/Debug.pme' => '/usr/share/perl5/Zevenet/Debug.pme'
		...
	};


Parameters:
	mod_space - .

Returns:
	undef
=cut
sub include
{
	my ( $mod_space ) = @_;

	my $debug = &debug();

	&zenlog("< include > mod_space = $mod_space") if $debug;

	my $path_prefix = &getGlobalConfiguration('zlibdir');
	$path_prefix =~ s|/Zevenet$||;

	&zenlog("< include > path_prefix = $path_prefix") if $debug;


	# get mod's path
	my $mod_path = $mod_space;
	$mod_path =~ s|::|/|g;

	&zenlog("< include > mod_path = $mod_path") if $debug;


	my $enc;
	my $mod_key;

	if ( -f "$path_prefix/$mod_path.pm" )
	{
		$enc          = 'false';
		$mod_key      = "$mod_path.pm";
	}
	elsif ( -f "$path_prefix/$mod_path.pme" )
	{
		$enc          = 'true';
		$mod_key      = "$mod_path.pme";
	}

	my $mod_fullpath = "$path_prefix/$mod_key";

	if ( $debug )
	{
		&zenlog( "< include > enc          = $enc" );
		&zenlog( "< include > mod_key      = $mod_key" );
		&zenlog( "< include > mod_fullpath = $mod_fullpath" );
	}


	# Finish if the module is already loaded
	return if exists $INC{ $mod_key };


	if ( $enc eq 'false' )    # Load unencrypted module
	{
		require $mod_fullpath;
	}
	elsif ( $enc eq 'true' )    # Load encrypted module
	{
		my $uname          = &getGlobalConfiguration( 'uname' );
		my $kernel_release = `$uname -r`;

		my $cmd = "openssl aes-256-cbc -d -a -nosalt -k \"${SYMKEY}\" -in ${mod_fullpath}";
		$cmd .= " -md md5" if $kernel_release =~ /^4.9/;

		# get code
		$code = `$cmd`;

		# load module
		eval $code;

		# log error messages if any happened
		if ( $@ )
		{
			&zenlog( "### Module name: $mod_space" );
			&zenlog( "### Module path: $mod_fullpath" );
			&zenlog( $@ );
			die $@;
		}
		else
		{
			$INC{ $mod_key } = $mod_fullpath;
		}
	}
}


### Activation certificate code ############
#~ use Time::Local;
#~ use Zevenet::Config;
#~ use Zevenet::SystemInfo;

# build local key
sub keycert
{
	my $dmi      = &get_sys_uuid();
	my $hostname = &getHostname();

	my $block1 = crypt ( "${dmi}${hostname}", "93" );
	my $block2 = crypt ( "${hostname}${dmi}", "a3" );
	my $block3 = crypt ( "${dmi}${hostname}", "ZH" );
	my $block4 = crypt ( "${hostname}${dmi}", "h7" );
	$block1 =~ s/^93//;
	$block2 =~ s/^a3//;
	$block3 =~ s/^ZH//;
	$block4 =~ s/^h7//;

	my $str = "${block1}-${block2}-${block3}-${block4}";

	return $str;
}

# evaluate certificate
sub certcontrol
{
	my $basedir = &getGlobalConfiguration( 'basedir' );
	my $zlbcertfile = "$basedir/zlbcertfile.pem";
	my $swcert = 0;

	if ( ! -e $zlbcertfile )
	{
		#swcert = 1 ==> There isn't certificate
		$swcert = 1;
		return $swcert;
	}

	my $openssl_bin = "/usr/bin/openssl";
	my $keyid       = "4B:1B:18:EE:21:4A:B6:F9:76:DE:C3:D8:86:6D:DE:98:DE:44:93:B9";
	my @months      = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
	my $hostname    = &getHostname();
	my $key         = &keycert();
	my @zen_cert    = `$openssl_bin x509 -in $zlbcertfile -noout -text 2>/dev/null`;

	if (    ( !grep /$key/, @zen_cert )
		 || ( !grep /keyid:$keyid/, @zen_cert )
		 || ( !grep /CN=$hostname\/|CN = $hostname\,/, @zen_cert ) )
	{
		#swcert = 2 ==> Cert isn't signed OK
		$swcert = 2;
		return $swcert;
	}

	# Certificate validity date
	my ( $nb ) = grep /Not Before/i, @zen_cert;
	$nb =~ s/.*not before.*:\ //i;

	my ( $month, $day, $hours, $min, $sec, $year ) = split /[ :]+/, $nb;
	( $month ) = grep { $months[$_] eq $month } 0..$#months;
	my $ini = timegm( $sec, $min, $hours, $day, $month, $year );

	# Certificate expiring date
	my ( $na ) = grep /Not After/i, @zen_cert;
	$na =~ s/.*not after.*:\ //i;

	( $month, $day, $hours, $min, $sec, $year ) = split /[ :]+/, $na;
	( $month ) = grep { $months[$_] eq $month } 0..$#months;
	my $end = timegm( $sec, $min, $hours, $day, $month, $year );

	# Validity remaining
	my $totaldays = ( $end - $ini ) / 86400;
	$totaldays =~ s/\-//g;
	my $dayright = ( $end - time () ) / 86400;

	if ( $dayright < 0 )
	{
		#control errors
		if ( $totaldays < 364 )
		{
			# Policy: expired testing certificates would not stop zen service,
			# but rebooting the service would not start the service,
			# interfaces should always be available.
			$swcert = 3;
		}

		if ( $totaldays > 364 )
		{
			# The contract support plan is expired you have to request a
			# new contract support. Only message alert!
			$swcert = -1;
		}
	}

	# error codes
	#swcert = 0 ==> OK
	#swcert = 1 ==> There isn't certificate
	#swcert = 2 ==> Cert isn't signed OK
	#swcert = 3 ==> Cert test and it's expired
	#swcert = -1 ==> Cert support and it's expired

	#output
	return $swcert;
}

sub get_sys_uuid
{
	my ( $dmi ) = grep ( /UUID\:/, `/usr/sbin/dmidecode` );
	( undef, $dmi ) = split ( /:\s+/, $dmi );

	chomp $dmi;

	return $dmi;
}

sub checkActivationCertificate
{
	my $swcert = &certcontrol();

	# if $swcert is greater than 0 zapi should not work
	if ( $swcert > 0 )
	{
		my $msg;

		if ( $swcert == 1 )
		{
			$msg =
			  "There isn't a valid Zen Load Balancer certificate file, please request a new one";
		}
		elsif ( $swcert == 2 )
		{
			$msg =
			  "The certificate file isn't signed by the Zevenet Certificate Authority, please request a new one";
		}
		elsif ( $swcert == 3 )
		{
			# Policy: expired testing certificates would not stop zen service,
			# but rebooting the service would not start the service,
			# interfaces should always be available.
			$msg =
			  "The Zen Load Balancer certificate file you are using is for testing purposes and its expired, please request a new one";
		}

		my $body = {
					 message         => $msg,
					 certificate_key => &keycert(),
					 hostname        => &getHostname(),
		};

		return &httpResponse( { code => 403, body => $body } );
	}

	return $swcert;
}
