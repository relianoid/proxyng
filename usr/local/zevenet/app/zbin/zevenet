#!/usr/bin/perl
###############################################################################
#
#    Zevenet Software License
#    This file is part of the Zevenet Load Balancer software package.
#
#    Copyright (C) 2014-today ZEVENET SL, Sevilla (Spain)
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

use strict;
use warnings;

# standard required modules
use Zevenet;
use Zevenet::Log;

# activation certificate modules
use Date::Parse;
use Time::localtime;

#~ use Tie::File;
#~ use Data::Dumper;

my $basedir      = &getGlobalConfiguration( 'basedir' );
my $configdir    = &getGlobalConfiguration( 'configdir' );
my $defaultgw    = &getGlobalConfiguration( 'defaultgw' );
my $defaultgwif  = &getGlobalConfiguration( 'defaultgwif' );
my $defaultgw6   = &getGlobalConfiguration( 'defaultgw6' );
my $defaultgwif6 = &getGlobalConfiguration( 'defaultgwif6' );
my $action       = shift @ARGV // '';

if ( $action !~ /stop|start|status/ )
{
	print "Usage: /etc/init.d/zevenet stop|start|status\n";
	exit 0;
}

sub printAndLog
{
	print( "@_\n" );
	zenlog( @_ );
}

# build local key
sub keycert    #()
{
	# requires:
	#~ use Sys::Hostname;

	my $dmidecode_bin = "/usr/sbin/dmidecode";    # input
	my $hostname      = &getHostname();               # input

	my @dmidec  = `$dmidecode_bin`;
	my @dmidec2 = grep ( /UUID\:/, @dmidec );
	my $dmi     = $dmidec2[0];

	$dmi =~ s/\"//g;     # remove doble quotes
	$dmi =~ s/^\s+//;    # remove whitespaces at the begining
	$dmi =~ s/\s+$//;    # remove whitespaces at the end
	$dmi =~ s/\ //g;     # remove spaces

	my @dmidec3 = split ( ":", $dmi );
	$dmi = $dmidec3[1];

	$hostname =~ s/\"//g;     # remove doble quotes
	$hostname =~ s/^\s+//;    # remove whitespaces at the begining
	$hostname =~ s/\s+$//;    # remove whitespaces at the end

	my $encrypted_string  = crypt ( "${dmi}${hostname}", "93" );
	my $encrypted_string2 = crypt ( "${hostname}${dmi}", "a3" );
	my $encrypted_string3 = crypt ( "${dmi}${hostname}", "ZH" );
	my $encrypted_string4 = crypt ( "${hostname}${dmi}", "h7" );
	$encrypted_string =~ s/^93//;
	$encrypted_string2 =~ s/^a3//;
	$encrypted_string3 =~ s/^ZH//;
	$encrypted_string4 =~ s/^h7//;

	my $str =
	  "${encrypted_string}-${encrypted_string2}-${encrypted_string3}-${encrypted_string4}";

	$str =~ s/\"//g;     # remove doble quotes
	$str =~ s/^\s+//;    # remove whitespaces at the begining
	$str =~ s/\s+$//;    # remove whitespaces at the end

	return $str;
}

# evaluate certificate
sub certcontrol          #()
{
	# requires:
	#~ use Sys::Hostname;
	#~ use Date::Parse;
	#~ use Time::localtime;

	# input
	my $hostname    = &getHostname();
	my $zlbcertfile = "$basedir/zlbcertfile.pem";
	my $openssl_bin = "/usr/bin/openssl";
	my $keyid       = "4B:1B:18:EE:21:4A:B6:F9:76:DE:C3:D8:86:6D:DE:98:DE:44:93:B9";

	# output
	my $swcert = 0;

	if ( -e $zlbcertfile )
	{
		my @zen_cert = `$openssl_bin x509 -in $zlbcertfile -noout -text 2>/dev/null`;
		my $key = &keycert();

		if (    ( !grep /$key/, @zen_cert )
			 || ( !grep /keyid:$keyid/,   @zen_cert )
			 || ( !grep /CN=$hostname\/|CN = $hostname\,/, @zen_cert ) )
		{
			$swcert = 2;
		}

		my $now = ctime();

		# Certificate validity date
		my @notbefore = grep /Not Before/i, @zen_cert;
		my $nb = join '', @notbefore;
		$nb =~ s/not before.*:\ //i;
		my $ini = str2time( $nb );

		# Certificate expiring date
		my @notafter = grep /Not After/i, @zen_cert;
		my $na = join "", @notafter;
		$na =~ s/not after.*:\ //i;
		my $end = str2time( $na );

		# Validity remaining
		my $totaldays = ( $end - $ini ) / 86400;
		$totaldays =~ s/\-//g;
		my $dayright = ( $end - time () ) / 86400;

		#control errors
		if ( $totaldays < 364 && $dayright < 0 && $swcert == 0 )
		{
			# Policy: expired testing certificates would not stop zen service,
			# but rebooting the service would not start the service,
			# interfaces should always be available.
			$swcert = 3;
		}

		if ( $totaldays > 364 && $dayright < 0 && $swcert == 0 )
		{
			# The contract support plan is expired you have to request a
			# new contract support. Only message alert!
			$swcert = -1;
		}
	}
	else
	{
		#There isn't certificate in the machine
		$swcert = 1;
	}

	# error codes
	#swcert = 0 ==> OK
	#swcert = 1 ==> There isn't certificate
	#swcert = 2 ==> Cert isn't signed OK
	#swcert = 3 ==> Cert test and it's expired
	#swcert = -1 ==> Cert support and it's expired

	#output
	return $swcert;
}
# end evaluate certificate

sub local_http_service
{
	my ( $command ) = @_;

	die "local_http_service command not recognized"
		unless $command =~ /^(?:start|stop)$/;

	system ( "/etc/init.d/cherokee $command >/dev/null &" );
}

if ( $action eq "restart" )
{
	system ( '/etc/init.d/zevenet stop' );
	system ( '/etc/init.d/zevenet start' );
}

if ( $action eq "start" )
{
	my $version = &getGlobalConfiguration('version');

	&printAndLog( "Starting Zevenet Load Balancer v$version" );

	# Load required modules
	system ( '/sbin/modprobe nf_conntrack >/dev/null 2>&1' );
	system ( '/sbin/modprobe ip_conntrack >/dev/null 2>&1' );
	system ( '/sbin/modprobe xt_recent >/dev/null 2>&1'   );

	&zenlog("zevenet: Modules loaded");

	# import system interface to zen if configured
	#testing interface configured on the installation and gw
	if ( -e '/etc/network/interfaces' )
	{
		open my $fr, '/etc/network/interfaces';
		my @file = <$fr>;
		close $fr;

		# FIXME: Make function of this procedure
		if ( !grep ( /zenmodified/, @file ) )
		{
			my ( $ifname, $ip, $netmask, $gateway );

			foreach my $line ( @file )
			{
				chomp ( $line );

				if ( $line =~ /iface.*inet static/i )
				{
					my ( undef, $ifname ) = split ( " ", $line );
				}
				if ( $line =~ /\Waddress/i )
				{
					my ( undef, $ip_n_mask ) = split ( " ", $line );
					my $mask;
					( $ip, $mask ) = split ( "/", $ip_n_mask );

					if ( $mask ) # only when bitmask is declared
					{
						use Net::Netmask;
						my $block = Net::Netmask->new2( $ip_n_mask );

						if ( $block ) {
							$netmask = $block->mask;
						}
						else {
							&zenlog( $Net::Netmask::error );
							die $Net::Netmask::error;
						}
					}
				}
				if ( $line =~ /netmask/i )
				{
					my ( undef, $netmask ) = split ( " ", $line );
				}
				if ( $line =~ /gateway/i )
				{
					my ( undef, $gateway ) = split ( " ", $line );
				}
			}

			#deleting interfaces file
			open FW, ">/etc/network/interfaces";
			print FW "#zenmodified\n";
			print FW "auto lo\n";
			print FW "iface lo inet loopback\n";
			close FW;

			my %interface = (
							  name    => $ifname,
							  addr    => $ip,
							  mask    => $netmask,
							  gateway => $gateway,
							  status  => "up",
							  name    => "$ifname",
			);

			&setInterfaceConfig( \%interface );

			# Configure gateway for first time
			# FIXME: use setGlobalConfiguration()
			my $globalcfg = "/usr/local/zevenet/config/global.conf";
			tie my @contents, 'Tie::File', "$globalcfg";

			for my $line ( @contents )
			{
				if ( grep /^\$defaultgw/, $line )    # FIXME: IPv6 gateway
				{
					$line =~ s/^\$defaultgw=.*/\$defaultgw="$gateway";/g;
					$line =~ s/^\$defaultgwif=.*/\$defaultgwif="$ifname";/g;
				}
			}

			untie @contents;

			# Routes
			# FIXME: there is a function for this, it should be used.
			open FW, ">>/etc/iproute2/rt_tables";
			print FW "200\ttable_$ifname\n";
			close FW;
		}
	}

	# enterprise hook
	if ( eval { require Zevenet::Service; } ) { start_service(); }
	else { zenlog( $@ ); }

	print ( "* Starting Interfaces:\n" );

	my $mgmt_ip    = &getHttpServerIp();
	my $ip_bin     = &getGlobalConfiguration( 'ip_bin' );
	my @interfaces = @{ &getConfigInterfaceList() };

	&zenlog("zevenet: Setting up NIC and Bonding interfaces...");

	# first real interfaces
	foreach my $iface ( @interfaces )
	{
		#interfaces as eth0 for example
		if ( $$iface{ name } eq $$iface{ dev } )
		{
			use IO::Interface ':flags';

			if ( $$iface{ status } eq "up" )
			{
				print ( "  * Starting interface $$iface{name}\n" );
				print ( "    Ip:$$iface{addr} Netmask:$$iface{mask}" );

				if ( $$iface{ gateway } )
				{
					print ( " Gateway:$$iface{gateway}" );
				}

				&upIf( $iface );
				my $return_code = &addIp( $iface );

				if ( $return_code )
				{
					my @ip_output = `$ip_bin address show dev $$iface{name}`;
					$return_code = 0 if ( grep /$$iface{addr}/, @ip_output );
				}

				# kept in case it is required for first interface
				&writeRoutes( $$iface{ name } );

				&applyRoutes( "local", $iface );

				if ( $return_code == 0 )
				{
					print ( " \033[1;32m OK \033[0m \n" );
				}
				else
				{
					print ( " \033[1;31m ERROR \033[0m \n" );
				}

				if ( $$iface{ ip_v } == 4 )
				{
					&sendGPing( $$iface{ name } );
				}
			}
		}
	}

	&zenlog("zevenet: Setting up VLAN interfaces...");

	# vlans interfaces (ie. eth0.20)
	foreach my $iface ( @interfaces )
	{
		if ( $$iface{ vlan } && ! $$iface{ vini } )
		{
			&createIf( $iface );
			my $return_code = &addIp( $iface );

			if ( $$iface{ status } eq "up" )
			{
				print ( "  * Starting interface $$iface{name}\n" );
				print ( "    Ip:$$iface{addr} Netmask:$$iface{mask}" );

				if ( $$iface{ gateway } )
				{
					print ( " Gateway:$$iface{gateway}" );
				}

				&upIf( $iface );

				if ( $return_code )
				{
					my @ip_output = `$ip_bin address show dev $$iface{name}`;
					$return_code = 0 if ( grep /$$iface{addr}/, @ip_output );
				}

				if ( $return_code == 0 )
				{
					print ( " \033[1;32m OK \033[0m \n" );
				}
				else
				{
					print ( " \033[1;31m ERROR \033[0m \n" );
				}

				&applyRoutes( "local", $iface );

				if ( $$iface{ ip_v } == 4 )
				{
					&sendGPing( $$iface{ name } );
				}
			}
		}
	}

	&zenlog("zevenet: Setting up Cluster...");

	# enable cluster hook
	if ( eval { require Zevenet::Service; } ) { enable_cluster(); }
	else { zenlog( $@ ); }

	&zenlog("zevenet: Setting up virtual interfaces...");

	# virtual interfaces (ie. eth0:20, eth0.20:2)
	foreach my $iface ( @interfaces )
	{
		if ( $$iface{ vini } )
		{
			if ( $$iface{ status } eq "up" )
			{
				print ( "  * Starting interface $$iface{name}\n" );
				print ( "    Ip:$$iface{addr} Netmask:$$iface{mask}" );

				my $return_code = &addIp( $iface );

				if ( $return_code )
				{
					my $toif = &getParentInterfaceName( $$iface{ name } );
					&zenlog( "failed addIp" );
					my @ip_output = `$ip_bin -$$iface{ip_v} address list dev $toif`;
					$return_code = 0 if ( grep /$$iface{addr}/, @ip_output );
				}

				&applyRoutes( "local", $iface );

				if ( $return_code == 0 )
				{
					print ( " \033[1;32m OK \033[0m \n" );
				}
				else
				{
					print ( " \033[1;31m ERROR \033[0m \n" );
				}

				if ( $$iface{ ip_v } == 4 )
				{
					my ( $parent_if ) = split ( ":", $$iface{ name } );
					&sendGPing( $parent_if );
				}
			}
		}
	}

	print ( "* Starting Farms:\n" );

	my @farmsf = &getFarmList();
	my $enable_fg = 1;

	if ( eval { require Zevenet::Service; } ) { $enable_fg = getEnableFarmGuardian(); }
	else { zenlog( $@ ); }

	&zenlog("zevenet: Setting up farms...");

	foreach my $ffile ( @farmsf )
	{
		my $farmname = &getFarmName( $ffile );
		my $bstatus  = &getFarmBootStatus( $farmname );

		if ( $bstatus eq "up" )
		{
			print ( "  * Starting Farm $farmname:" );
			my $status = &_runFarmStart( $farmname, "false" );

			if ( $status == 0 )
			{
				print ( " \033[1;32m OK \033[0m \n" );
			}
			else
			{
				print ( " \033[1;31m ERROR \033[0m \n" );
			}

			#farmguardian configured and up?
			my $fgstatus = &getFarmGuardianStatus( $farmname );

			if ( ( $status == 0 ) && ( $fgstatus == 1 ) && $enable_fg )
			{
				print ( "  * Starting Farm Guardian for $farmname:" );
				my $stat = &runFarmGuardianStart( $farmname, "" );

				if ( $stat == 0 )
				{
					print ( " \033[1;32m OK \033[0m \n" );
				}
				else
				{
					print ( " \033[1;31m ERROR \033[0m \n" );
				}
			}
		}
		else
		{
			print ( "  Farm $farmname configured DOWN\n" );
		}
	}

	# At this point every zevenet interface and farm is running
	# now a personalized script can be executed
	&printAndLog("Running $configdir/zlb-start ...");

	my @ownscript = `$configdir/zlb-start 2>&1`;
	&printAndLog( @ownscript ) if ( @ownscript );

	&printAndLog("End of $configdir/zlb-start");

	if ( eval { require Zevenet::Service; } ) { start_cluster(); }
	else { zenlog( $@ ); }

	# make sure related system services are runnig
	if ( system( "/etc/init.d/ssh status >/dev/null 2>&1" ) ) {
		 system( "/etc/init.d/ssh start >/dev/null 2>&1" );
	}

	&local_http_service('start');

	&printAndLog( "Start proccess finished." );
}

if ( $action eq "stop" )
{
	&printAndLog( "Stopping Zevenet Load Balancer...\n" );

	if ( eval { require Zevenet::Service; } ) { stop_service(); }
	else { zenlog( $@ ); }

	print ( "* Stopping Farms:\n" );

	foreach my $ffile ( getFarmList() )
	{
		my $farmname = &getFarmName( $ffile );
		my $status   = &getFarmStatus( $farmname );

		if ( $status eq "up" )
		{
			#farmguardian configured and up?
			my $fgstatus = &getFarmGuardianPid( $farmname );

			if ( $fgstatus != -1 )
			{
				print ( "  * Stopping Farm Guardian for $farmname:" );
				my $stat = &runFarmGuardianStop( $farmname, "" );

				if ( $stat == 0 )
				{
					print ( " \033[1;32m OK \033[0m \n" );
				}
				else
				{
					print ( " \033[1;31m ERROR \033[0m \n" );
				}
			}

			print ( "  * Stopping Farm $farmname:" );
			my $status = &_runFarmStop( $farmname, "false" );

			if ( $status == 0 )
			{
				print ( " \033[1;32m OK \033[0m \n" );
			}
			else
			{
				print ( " \033[1;31m ERROR \033[0m \n" );
			}
		}
	}

	print ( "* Stopping Virtual Interfaces:\n" );

	# Virtual Network Interfaces
	foreach my $iface ( @{ &getConfigInterfaceList() } )
	{
		if ( $$iface{ vini } )
		{
			print ( "  * Down interface $$iface{name}\n" );
			print ( "    Ip:$$iface{addr} Netmask:$$iface{mask}" );

			my $return_code = &stopIf( $iface );

			if ( $return_code == 0 )
			{
				print ( " \033[1;32m OK \033[0m \n" );
			}
			else
			{
				print ( " \033[1;31m ERROR \033[0m \n" );
			}
		}
	}

	if ( eval { require Zevenet::Service; } ) { disable_cluster(); }
	else { zenlog( $@ ); }

	# At this point every zevenet interface and farm is stopped
	# now a personalized script can be executed
	&printAndLog("Running $configdir/zlb-stop ...");

	my @ownscript = `$configdir/zlb-stop 2>&1`;
	&printAndLog( @ownscript ) if @ownscript;

	&printAndLog( "End of $configdir/zlb-stop" );

	&printAndLog( "Stop process finished..." );
}

&configureDefaultGW();
